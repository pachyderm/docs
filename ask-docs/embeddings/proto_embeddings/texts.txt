[Document(page_content='syntax = "proto3";\n\npackage license_v2;\noption go_package = "github.com/pachyderm/pachyderm/v2/src/license";\n\nimport "google/protobuf/timestamp.proto";\nimport "gogoproto/gogo.proto";\nimport "enterprise/enterprise.proto";\nimport "protoextensions/log.proto";', metadata={'source': 'protobufs/license.proto'}), Document(page_content="message ActivateRequest {\n  // activation_code is a Pachyderm enterprise activation code. New users can\n  // obtain trial activation codes\n  string activation_code = 1 [(log.half) = true];\n\n  // expires is a timestamp indicating when this activation code will expire.\n  // This should not generally be set (it's primarily used for testing), and is\n  // only applied if it's earlier than the signed expiration time in\n  // 'activation_code'.\n  google.protobuf.Timestamp expires = 2;\n}\n\nmessage ActivateResponse {\n  enterprise_v2.TokenInfo info = 1;\n}\n\nmessage GetActivationCodeRequest {}", metadata={'source': 'protobufs/license.proto'}), Document(page_content='message GetActivationCodeRequest {}\n\nmessage GetActivationCodeResponse {\n  enterprise_v2.State state = 1;\n  enterprise_v2.TokenInfo info = 2;\n  string activation_code = 3 [(log.half) = true];\n}\n\nmessage DeactivateRequest{}\nmessage DeactivateResponse{}', metadata={'source': 'protobufs/license.proto'}), Document(page_content='message AddClusterRequest {\n  // id is the unique, immutable identifier for this cluster\n  string id = 1;\n  // address is the public GPRC address where the cluster can be reached\n  string address = 2;\n  // If set, secret specifies the shared secret this cluster will use\n  // to authenticate to the license server. Otherwise a secret will be\n  // generated and returned in the response.\n  string secret = 3 [(log.half) = true];\n  // The pachd address for users to connect to.\n  string user_address = 4;\n  // The deployment ID value generated by each Cluster\n  string cluster_deployment_id = 5;', metadata={'source': 'protobufs/license.proto'}), Document(page_content='string cluster_deployment_id = 5;\n  // This field indicates whether the address points to an enterprise server\n  bool enterprise_server = 6;\n}', metadata={'source': 'protobufs/license.proto'}), Document(page_content='message AddClusterResponse {\n  string secret = 1 [(log.half) = true];\n}\n\nmessage DeleteClusterRequest {\n  string id = 1;\n}\nmessage DeleteClusterResponse {}', metadata={'source': 'protobufs/license.proto'}), Document(page_content='message ClusterStatus {\n  string id = 1;\n  string address = 2;\n  string version = 3;\n  bool auth_enabled = 4 [(gogoproto.moretags) = "db:\\"auth_enabled\\""];\n  string client_id = 7 [(gogoproto.moretags) = "db:\\"client_id\\""];\n  google.protobuf.Timestamp last_heartbeat = 5 [(gogoproto.moretags) = "db:\\"last_heartbeat\\"", (gogoproto.stdtime) = true];\n  google.protobuf.Timestamp created_at = 6 [(gogoproto.moretags) = "db:\\"created_at\\"", (gogoproto.stdtime) = true];\n}', metadata={'source': 'protobufs/license.proto'}), Document(page_content='// Note: Updates of the enterprise-server field are not allowed. In the worst case, a user can recreate their cluster if they need the field updated.', metadata={'source': 'protobufs/license.proto'}), Document(page_content='message UpdateClusterRequest {\n  string id = 1;\n  string address = 2;\n  string user_address = 3;\n  string cluster_deployment_id = 4;\n  string secret = 5;\n}\nmessage UpdateClusterResponse{}\n\nmessage ListClustersRequest {}\nmessage ListClustersResponse {\n  repeated ClusterStatus clusters = 1;\n}\n\nmessage DeleteAllRequest{}\nmessage DeleteAllResponse {}\n\nmessage HeartbeatRequest {\n  string id = 1;\n  string secret = 2 [(log.half) = true];\n  string version = 3;\n  bool auth_enabled = 4;\n  string client_id = 5;\n}\n\nmessage HeartbeatResponse {\n  enterprise_v2.LicenseRecord license = 1;\n}', metadata={'source': 'protobufs/license.proto'}), Document(page_content='message UserClusterInfo {\n  string id = 1 [(gogoproto.moretags) = "db:\\"id\\""];\n  string cluster_deployment_id = 2 [(gogoproto.moretags) = "db:\\"cluster_deployment_id\\""];\n  string address = 3 [(gogoproto.moretags) = "db:\\"user_address\\""];\n  bool enterprise_server = 4 [(gogoproto.moretags) = "db:\\"is_enterprise_server\\""];\n}\n\nmessage ListUserClustersRequest {}', metadata={'source': 'protobufs/license.proto'}), Document(page_content='message ListUserClustersResponse {\n  repeated UserClusterInfo clusters = 1;\n}', metadata={'source': 'protobufs/license.proto'}), Document(page_content='service API {\n  // Activate enables the license service by setting the enterprise activation\n  // code to serve.\n  rpc Activate(ActivateRequest) returns (ActivateResponse) {}\n  rpc GetActivationCode(GetActivationCodeRequest) returns (GetActivationCodeResponse) {}\n\n  // DeleteAll deactivates the server and removes all data.\n  rpc DeleteAll(DeleteAllRequest) returns (DeleteAllResponse) {}', metadata={'source': 'protobufs/license.proto'}), Document(page_content='// CRUD operations for the pachds registered with this server.\n  rpc AddCluster(AddClusterRequest) returns (AddClusterResponse) {}\n  rpc DeleteCluster(DeleteClusterRequest) returns (DeleteClusterResponse) {}\n  rpc ListClusters(ListClustersRequest) returns (ListClustersResponse) {}\n  rpc UpdateCluster(UpdateClusterRequest) returns (UpdateClusterResponse) {}\n\n  // Heartbeat is the RPC registered pachds make to the license server\n  // to communicate their status and fetch updates.\n  rpc Heartbeat(HeartbeatRequest) returns (HeartbeatResponse) {}', metadata={'source': 'protobufs/license.proto'}), Document(page_content='// Lists all clusters available to user\n  rpc ListUserClusters(ListUserClustersRequest) returns (ListUserClustersResponse) {}\n}', metadata={'source': 'protobufs/license.proto'})]


[Document(page_content='syntax = "proto3";\n\npackage datum;\noption go_package = "github.com/pachyderm/pachyderm/v2/src/server/worker/datum";\n\nimport "gogoproto/gogo.proto";\n\nimport "pfs/pfs.proto";\nimport "pps/pps.proto";\nimport "server/worker/common/common.proto";\n\nenum State {\n  PROCESSED = 0;\n  FAILED = 1;\n  RECOVERED = 2;\n}\n\nmessage Meta {\n  pps_v2.Job job = 1;\n  repeated common.Input inputs = 2;\n  string hash = 3;\n  State state = 4;\n  string reason = 5;\n  pps_v2.ProcessStats stats = 6;\n  int64 index = 7;\n  string image_id = 8;\n}', metadata={'source': 'protobufs/datum.proto'}), Document(page_content='message Stats {\n  pps_v2.ProcessStats process_stats = 1;\n  int64 processed = 2;\n  int64 skipped = 3;\n  int64 total = 4;\n  int64 failed = 5;\n  int64 recovered = 6;\n  string failed_id = 7 [(gogoproto.customname) = "FailedID"];\n}\n\nmessage PFSTask {\n  pps_v2.PFSInput input = 1; \n  pfs_v2.PathRange path_range = 2;\n  int64 base_index = 3;\n  string auth_token = 4;\n}\n\nmessage PFSTaskResult {\n  string file_set_id = 1;\n}', metadata={'source': 'protobufs/datum.proto'}), Document(page_content='message PFSTaskResult {\n  string file_set_id = 1;\n}\n\nmessage CrossTask {\n  repeated string file_set_ids = 1;\n  int64 base_file_set_index = 2;\n  pfs_v2.PathRange base_file_set_path_range = 3;\n  int64 base_index = 4;\n  string auth_token = 5;\n}\n\nmessage CrossTaskResult {\n  string file_set_id = 1;\n}\n\nmessage KeyTask {\n  string file_set_id = 1;\n  pfs_v2.PathRange path_range = 2;\n  enum Type {\n    JOIN = 0;\n    GROUP = 1;\n  }\n  Type type = 3;\n  string auth_token = 4;\n}\n\nmessage KeyTaskResult {\n  string file_set_id = 1;\n}', metadata={'source': 'protobufs/datum.proto'}), Document(page_content='message KeyTaskResult {\n  string file_set_id = 1;\n}\n\nmessage MergeTask {\n  repeated string file_set_ids = 1;\n  pfs_v2.PathRange path_range = 2;\n  enum Type {\n    JOIN = 0;\n    GROUP = 1;\n  }\n  Type type = 3;\n  string auth_token = 4;\n}\n\nmessage MergeTaskResult {\n  string file_set_id = 1;\n}\n\nmessage ComposeTask {\n  repeated string file_set_ids = 1;\n  string auth_token = 2;\n}\n\nmessage ComposeTaskResult {\n  string file_set_id = 1;\n}\n\nmessage SetSpec {\n  int64 number = 1;\n  int64 size_bytes = 2;\n}', metadata={'source': 'protobufs/datum.proto'})]


[Document(page_content='syntax = "proto3";\n\npackage pachyderm.worker.pipeline.transform;\noption go_package = "github.com/pachyderm/pachyderm/v2/src/server/worker/pipeline/transform";\n\nimport "gogoproto/gogo.proto";\n\nimport "pfs/pfs.proto";\nimport "pps/pps.proto";\nimport "server/worker/datum/datum.proto";\n\nmessage CreateParallelDatumsTask {\n  pps_v2.Job job = 1;\n  string salt = 2;\n  string file_set_id = 3;\n  string base_file_set_id = 4;\n  pfs_v2.PathRange path_range = 5;\n} \n\nmessage CreateParallelDatumsTaskResult {\n  string file_set_id = 1;\n  datum.Stats stats = 2;\n}', metadata={'source': 'protobufs/transform.proto'}), Document(page_content='message CreateSerialDatumsTask {\n  pps_v2.Job job = 1;\n  string salt = 2;\n  string file_set_id = 3;\n  pfs_v2.Commit base_meta_commit = 4;\n  bool no_skip = 5;\n  pfs_v2.PathRange path_range = 6;\n}\n\nmessage CreateSerialDatumsTaskResult {\n  string file_set_id = 1;\n  string output_delete_file_set_id = 2;\n  string meta_delete_file_set_id = 3;\n  datum.Stats stats = 4;\n} \n\nmessage CreateDatumSetsTask {\n  string file_set_id = 1;\n  pfs_v2.PathRange path_range = 2;\n  datum.SetSpec set_spec = 3;\n} \n\nmessage CreateDatumSetsTaskResult {\n  repeated pfs_v2.PathRange datum_sets = 1;\n}', metadata={'source': 'protobufs/transform.proto'}), Document(page_content='message DatumSetTask {\n  pps_v2.Job job = 1;\n  string file_set_id = 2;\n  pfs_v2.PathRange path_range = 3;\n  pfs_v2.Commit output_commit = 4;\n}\n\nmessage DatumSetTaskResult {\n  string output_file_set_id = 1;\n  string meta_file_set_id = 2;\n  datum.Stats stats = 3;\n}', metadata={'source': 'protobufs/transform.proto'})]


[Document(page_content='syntax = "proto3";\n\npackage pachyderm.worker;\noption go_package = "github.com/pachyderm/pachyderm/v2/src/worker";\n\nimport "pps/pps.proto";\nimport "gogoproto/gogo.proto";\nimport "google/protobuf/empty.proto";\n\nmessage CancelRequest {\n  string job_id = 1 [(gogoproto.customname) = "JobID"];\n  repeated string data_filters = 2;\n}', metadata={'source': 'protobufs/worker.proto'}), Document(page_content='message CancelResponse {\n  bool success = 1;\n}\n\n// Error indicates that the processing of the current datum errored.\n// Datum error semantics with datum batching enabled are similar to datum error\n// semantics without datum batching enabled in that the datum may be retried,\n// recovered, or result with a job failure.\nmessage NextDatumRequest {\n  string error = 1;\n}\n\n// Env is a list of environment variables that should be set for the processing\n// of the next datum.', metadata={'source': 'protobufs/worker.proto'}), Document(page_content='message NextDatumResponse {\n  repeated string env = 1;\n}', metadata={'source': 'protobufs/worker.proto'}), Document(page_content="service Worker {\n  rpc Status(google.protobuf.Empty) returns (pps_v2.WorkerStatus) {}\n  rpc Cancel(CancelRequest) returns (CancelResponse) {}\n  // NextDatum should only be called by user code running in a pipeline with\n  // datum batching enabled.\n  // NextDatum will signal to the worker code that the user code is ready to\n  // proceed to the next datum. This generally means setting up the next\n  // datum's filesystem state and updating internal metadata similarly to datum\n  // processing in a normal pipeline.\n  // NextDatum is a synchronous operation, so user code should expect to block", metadata={'source': 'protobufs/worker.proto'}), Document(page_content='// on this until the next datum is set up for processing.\n  // User code should generally be migratable to datum batching by wrapping it\n  // in a loop that calls next datum.\n  rpc NextDatum(NextDatumRequest) returns (NextDatumResponse) {}\n}', metadata={'source': 'protobufs/worker.proto'})]


[Document(page_content='syntax = "proto3";\n\npackage transaction_v2;\noption go_package = "github.com/pachyderm/pachyderm/v2/src/transaction";\n\nimport "google/protobuf/empty.proto";\nimport "google/protobuf/timestamp.proto";\n\nimport "gogoproto/gogo.proto";\n\nimport "pfs/pfs.proto";\nimport "pps/pps.proto";\n\nmessage DeleteAllRequest {\n}', metadata={'source': 'protobufs/transaction.proto'}), Document(page_content='message DeleteAllRequest {\n}\n\nmessage TransactionRequest {\n  // Exactly one of these fields should be set\n  pfs_v2.CreateRepoRequest create_repo = 1;\n  pfs_v2.DeleteRepoRequest delete_repo = 2;\n  pfs_v2.StartCommitRequest start_commit = 3;\n  pfs_v2.FinishCommitRequest finish_commit = 4;\n  pfs_v2.SquashCommitSetRequest squash_commit_set = 5;\n  pfs_v2.CreateBranchRequest create_branch = 6;\n  pfs_v2.DeleteBranchRequest delete_branch = 7;\n  pps_v2.UpdateJobStateRequest update_job_state = 8;\n  pps_v2.CreatePipelineRequest create_pipeline = 9;\n  pps_v2.StopJobRequest stop_job = 10;\n}', metadata={'source': 'protobufs/transaction.proto'}), Document(page_content='message TransactionResponse {\n  // At most, one of these fields should be set (most responses are empty)\n  pfs_v2.Commit commit = 1; // Only used for StartCommit - any way we can deterministically provide this before finishing the transaction?\n}\n\nmessage Transaction {\n  string id = 1 [(gogoproto.customname) = "ID"];\n}\n\nmessage TransactionInfo {\n  Transaction transaction = 1;\n  repeated TransactionRequest requests = 2;\n  repeated TransactionResponse responses = 3;\n  google.protobuf.Timestamp started = 4;\n  uint64 version = 5;\n}', metadata={'source': 'protobufs/transaction.proto'}), Document(page_content='message TransactionInfos {\n  repeated TransactionInfo transaction_info = 1;\n}\n\nmessage BatchTransactionRequest {\n  repeated TransactionRequest requests = 1;\n}\n\nmessage StartTransactionRequest {\n}\n\nmessage InspectTransactionRequest {\n  Transaction transaction = 1;\n}\n\nmessage DeleteTransactionRequest {\n  Transaction transaction = 1;\n}\n\nmessage ListTransactionRequest {\n}', metadata={'source': 'protobufs/transaction.proto'}), Document(page_content='message FinishTransactionRequest {\n  Transaction transaction = 1;\n}', metadata={'source': 'protobufs/transaction.proto'}), Document(page_content='service API {\n  // Transaction rpcs\n  rpc BatchTransaction(BatchTransactionRequest) returns (TransactionInfo) {}\n  rpc StartTransaction(StartTransactionRequest) returns (Transaction) {}\n  rpc InspectTransaction(InspectTransactionRequest) returns (TransactionInfo) {}\n  rpc DeleteTransaction(DeleteTransactionRequest) returns (google.protobuf.Empty) {}\n  rpc ListTransaction(ListTransactionRequest) returns (TransactionInfos) {}\n  rpc FinishTransaction(FinishTransactionRequest) returns (TransactionInfo) {}\n  rpc DeleteAll(DeleteAllRequest) returns (google.protobuf.Empty) {}\n}', metadata={'source': 'protobufs/transaction.proto'})]


[Document(page_content='syntax = "proto3";\n\npackage fileset;\noption go_package = "github.com/pachyderm/pachyderm/v2/src/internal/storage/fileset";\n\nimport "internal/storage/fileset/index/index.proto";\n\nmessage Metadata {\n  oneof value {\n    Primitive primitive = 1;\n    Composite composite = 2;\n  }\n}\n\nmessage Composite {\n  repeated string layers = 1;\n}\n\nmessage Primitive {\n  index.Index deletive = 1;\n  index.Index additive = 2;\n  int64 size_bytes = 3;\n}\n\nmessage TestCacheValue {\n  string file_set_id = 1;\n}', metadata={'source': 'protobufs/fileset.proto'})]


[Document(page_content='syntax = "proto3";\n\npackage metrics;\noption go_package = "github.com/pachyderm/pachyderm/v2/src/internal/metrics";\n\nimport "gogoproto/gogo.proto";', metadata={'source': 'protobufs/metrics.proto'}), Document(page_content='message Metrics {\n    string cluster_id              =  1 [(gogoproto.customname) = "ClusterID"];\n    string pod_id                  =  2 [(gogoproto.customname) = "PodID"];\n    int64 nodes                    =  3;\n    string version                 =  4;\n    int64 repos                    =  5; // Number of repos\n    int64 commits                  =  6; // Number of commits -- not used\n    int64 files                    =  7; // Number of files -- not used\n    uint64 bytes                   =  8; // Number of bytes in all repos\n    int64 jobs                     =  9; // Number of jobs', metadata={'source': 'protobufs/metrics.proto'}), Document(page_content='int64 jobs                     =  9; // Number of jobs\n    int64 pipelines                = 10; // Number of pipelines in the cluster -- not the same as DAG\n    int64 archived_commits         = 11; // Number of archived commit -- not used\n    int64 cancelled_commits        = 12; // Number of cancelled commits -- not used\n    string activation_code         = 13; // Activation code\n    uint64 max_branches            = 14; // Max branches in across all the repos\n    int64 pps_spout                = 15; // Number of spout pipelines', metadata={'source': 'protobufs/metrics.proto'}), Document(page_content='int64 pps_spout_service        = 16; // Number of spout services\n    reserved 17; // int64 pps_build\n    int64 cfg_egress               = 18; // Number of pipelines with Egress configured\n    int64 cfg_standby              = 19; // Number of pipelines with Standby congigured\n    int64 cfg_s3gateway            = 20; // Number of pipelines with S3 Gateway configured\n    int64 cfg_services             = 21; // Number of pipelines with services configured\n    int64 cfg_errcmd               = 22; // Number of pipelines with error cmd set', metadata={'source': 'protobufs/metrics.proto'}), Document(page_content='int64 cfg_tfjob                = 24; // Number of pipelines with TFJobs configured\n    int64 input_group              = 25; // Number of pipelines with group inputs\n    int64 input_join               = 26; // Number of pipelines with join inputs\n    int64 input_cross              = 27; // Number of pipelines with cross inputs\n    int64 input_union              = 28; // Number of pipelines with union inputs\n    int64 input_cron               = 29; // Number of pipelines with cron inputs\n    int64 input_git                = 30; // Number of pipelines with git inputs', metadata={'source': 'protobufs/metrics.proto'}), Document(page_content='int64 input_pfs                = 31; // Number of pfs inputs\n    int64 input_commit             = 32; // Number of pfs inputs with commits\n    int64 input_join_on            = 33; // Number of pfs inputs with join_on\n    int64 input_outer_join         = 34; // Number of pipelines with outer joins\n    int64 input_lazy               = 35; // Number of pipelines with lazy set\n    int64 input_empty_files        = 36; // Number of pipelines with empty files set\n    int64 input_s3                 = 37; // Number of pipelines with S3 input', metadata={'source': 'protobufs/metrics.proto'}), Document(page_content='int64 input_trigger            = 38; // Number of pipelines with triggers set\n    float resource_cpu_req         = 39; // Total CPU request across all pipelines\n    float resource_cpu_req_max     = 40; // Max CPU resource requests set\n    string resource_mem_req        = 41; // Sting of memory requests set across all pipelines\n    int64 resource_gpu_req         = 42; // Total GPU requests across all pipelines\n    int64 resource_gpu_req_max     = 43; // Max GPU request across all pipelines\n    string resource_disk_req       = 44; // String of disk requests set across all pipelines', metadata={'source': 'protobufs/metrics.proto'}), Document(page_content='float resource_cpu_limit       = 45; // Total CPU limits set across all pipelines\n    float resource_cpu_limit_max   = 46; // Max CPU limit set\n    string resource_mem_limit      = 47; // String of memory limits set\n    int64 resource_gpu_limit       = 48; // Number of pipelines with\n    int64 resource_gpu_limit_max   = 49; // Max GPU limit set\n    string resource_disk_limit     = 50; // String of disk limits set across all pipelines\n    uint64 max_parallelism         = 51; // Max parallelism set\n    uint64 min_parallelism         = 52; // Min parallelism set', metadata={'source': 'protobufs/metrics.proto'}), Document(page_content='uint64 num_parallelism         = 53; // Number of pipelines with parallelism set\n    int64 enterprise_failures      = 54; // Number of times a command has failed due to an enterprise check\n}', metadata={'source': 'protobufs/metrics.proto'})]


[Document(page_content='syntax = "proto3";\n\npackage taskapi;\noption go_package = "github.com/pachyderm/pachyderm/v2/src/task";\n\nimport "gogoproto/gogo.proto";\n\nenum State {\n  UNKNOWN = 0;\n  RUNNING = 1;\n  SUCCESS = 2;\n  FAILURE = 3;\n  CLAIMED = 4; // not a real state used by task logic\n}\n\nmessage Group {\n  string namespace = 1;\n  string group = 2;\n}\n\nmessage TaskInfo {\n  string id = 1 [(gogoproto.customname) = "ID"];\n  Group group = 2;\n  State state = 3;\n  string reason = 4;\n  string input_type = 5;\n  string input_data = 6;\n}\n\nmessage ListTaskRequest {\n  Group group = 1;\n}', metadata={'source': 'protobufs/task.proto'})]


[Document(page_content='syntax = "proto3";\nsyntax = "proto3";\n\npackage transaction_v2;\noption go_package = "github.com/pachyderm/pachyderm/v2/src/transaction";\n\nimport "google/protobuf/empty.proto";\nimport "google/protobuf/timestamp.proto";\n\nimport "gogoproto/gogo.proto";\n\nimport "pfs/pfs.proto";\nimport "pps/pps.proto";\n\nmessage DeleteAllRequest {\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message DeleteAllRequest {\n}\n\nmessage TransactionRequest {\n  // Exactly one of these fields should be set\n  pfs_v2.CreateRepoRequest create_repo = 1;\n  pfs_v2.DeleteRepoRequest delete_repo = 2;\n  pfs_v2.StartCommitRequest start_commit = 3;\n  pfs_v2.FinishCommitRequest finish_commit = 4;\n  pfs_v2.SquashCommitSetRequest squash_commit_set = 5;\n  pfs_v2.CreateBranchRequest create_branch = 6;\n  pfs_v2.DeleteBranchRequest delete_branch = 7;\n  pps_v2.UpdateJobStateRequest update_job_state = 8;\n  pps_v2.CreatePipelineRequest create_pipeline = 9;\n  pps_v2.StopJobRequest stop_job = 10;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message TransactionResponse {\n  // At most, one of these fields should be set (most responses are empty)\n  pfs_v2.Commit commit = 1; // Only used for StartCommit - any way we can deterministically provide this before finishing the transaction?\n}\n\nmessage Transaction {\n  string id = 1 [(gogoproto.customname) = "ID"];\n}\n\nmessage TransactionInfo {\n  Transaction transaction = 1;\n  repeated TransactionRequest requests = 2;\n  repeated TransactionResponse responses = 3;\n  google.protobuf.Timestamp started = 4;\n  uint64 version = 5;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message TransactionInfos {\n  repeated TransactionInfo transaction_info = 1;\n}\n\nmessage BatchTransactionRequest {\n  repeated TransactionRequest requests = 1;\n}\n\nmessage StartTransactionRequest {\n}\n\nmessage InspectTransactionRequest {\n  Transaction transaction = 1;\n}\n\nmessage DeleteTransactionRequest {\n  Transaction transaction = 1;\n}\n\nmessage ListTransactionRequest {\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message FinishTransactionRequest {\n  Transaction transaction = 1;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='service API {\n  // Transaction rpcs\n  rpc BatchTransaction(BatchTransactionRequest) returns (TransactionInfo) {}\n  rpc StartTransaction(StartTransactionRequest) returns (Transaction) {}\n  rpc InspectTransaction(InspectTransactionRequest) returns (TransactionInfo) {}\n  rpc DeleteTransaction(DeleteTransactionRequest) returns (google.protobuf.Empty) {}\n  rpc ListTransaction(ListTransactionRequest) returns (TransactionInfos) {}\n  rpc FinishTransaction(FinishTransactionRequest) returns (TransactionInfo) {}\n  rpc DeleteAll(DeleteAllRequest) returns (google.protobuf.Empty) {}\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='syntax = "proto3";\n\npackage proxy;', metadata={'source': 'protobufs/main.proto'}), Document(page_content='option go_package = "github.com/pachyderm/pachyderm/v2/src/proxy";', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message ListenRequest {\n  string channel = 1;\n}\n\nmessage ListenResponse {\n  string extra = 1;\n}\n\nservice API {\n  // Listen streams database events. \n  // It signals that it is internally set up by sending an initial empty ListenResponse.\n  rpc Listen(ListenRequest) returns (stream ListenResponse) {}\n}\n\nsyntax = "proto3";\n\npackage license_v2;\noption go_package = "github.com/pachyderm/pachyderm/v2/src/license";\n\nimport "google/protobuf/timestamp.proto";\nimport "gogoproto/gogo.proto";\nimport "enterprise/enterprise.proto";\nimport "protoextensions/log.proto";', metadata={'source': 'protobufs/main.proto'}), Document(page_content="message ActivateRequest {\n  // activation_code is a Pachyderm enterprise activation code. New users can\n  // obtain trial activation codes\n  string activation_code = 1 [(log.half) = true];\n\n  // expires is a timestamp indicating when this activation code will expire.\n  // This should not generally be set (it's primarily used for testing), and is\n  // only applied if it's earlier than the signed expiration time in\n  // 'activation_code'.\n  google.protobuf.Timestamp expires = 2;\n}\n\nmessage ActivateResponse {\n  enterprise_v2.TokenInfo info = 1;\n}\n\nmessage GetActivationCodeRequest {}", metadata={'source': 'protobufs/main.proto'}), Document(page_content='message GetActivationCodeRequest {}\n\nmessage GetActivationCodeResponse {\n  enterprise_v2.State state = 1;\n  enterprise_v2.TokenInfo info = 2;\n  string activation_code = 3 [(log.half) = true];\n}\n\nmessage DeactivateRequest{}\nmessage DeactivateResponse{}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message AddClusterRequest {\n  // id is the unique, immutable identifier for this cluster\n  string id = 1;\n  // address is the public GPRC address where the cluster can be reached\n  string address = 2;\n  // If set, secret specifies the shared secret this cluster will use\n  // to authenticate to the license server. Otherwise a secret will be\n  // generated and returned in the response.\n  string secret = 3 [(log.half) = true];\n  // The pachd address for users to connect to.\n  string user_address = 4;\n  // The deployment ID value generated by each Cluster\n  string cluster_deployment_id = 5;', metadata={'source': 'protobufs/main.proto'}), Document(page_content='string cluster_deployment_id = 5;\n  // This field indicates whether the address points to an enterprise server\n  bool enterprise_server = 6;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message AddClusterResponse {\n  string secret = 1 [(log.half) = true];\n}\n\nmessage DeleteClusterRequest {\n  string id = 1;\n}\nmessage DeleteClusterResponse {}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message ClusterStatus {\n  string id = 1;\n  string address = 2;\n  string version = 3;\n  bool auth_enabled = 4 [(gogoproto.moretags) = "db:\\"auth_enabled\\""];\n  string client_id = 7 [(gogoproto.moretags) = "db:\\"client_id\\""];\n  google.protobuf.Timestamp last_heartbeat = 5 [(gogoproto.moretags) = "db:\\"last_heartbeat\\"", (gogoproto.stdtime) = true];\n  google.protobuf.Timestamp created_at = 6 [(gogoproto.moretags) = "db:\\"created_at\\"", (gogoproto.stdtime) = true];\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='// Note: Updates of the enterprise-server field are not allowed. In the worst case, a user can recreate their cluster if they need the field updated.', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message UpdateClusterRequest {\n  string id = 1;\n  string address = 2;\n  string user_address = 3;\n  string cluster_deployment_id = 4;\n  string secret = 5;\n}\nmessage UpdateClusterResponse{}\n\nmessage ListClustersRequest {}\nmessage ListClustersResponse {\n  repeated ClusterStatus clusters = 1;\n}\n\nmessage DeleteAllRequest{}\nmessage DeleteAllResponse {}\n\nmessage HeartbeatRequest {\n  string id = 1;\n  string secret = 2 [(log.half) = true];\n  string version = 3;\n  bool auth_enabled = 4;\n  string client_id = 5;\n}\n\nmessage HeartbeatResponse {\n  enterprise_v2.LicenseRecord license = 1;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message UserClusterInfo {\n  string id = 1 [(gogoproto.moretags) = "db:\\"id\\""];\n  string cluster_deployment_id = 2 [(gogoproto.moretags) = "db:\\"cluster_deployment_id\\""];\n  string address = 3 [(gogoproto.moretags) = "db:\\"user_address\\""];\n  bool enterprise_server = 4 [(gogoproto.moretags) = "db:\\"is_enterprise_server\\""];\n}\n\nmessage ListUserClustersRequest {}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message ListUserClustersResponse {\n  repeated UserClusterInfo clusters = 1;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='service API {\n  // Activate enables the license service by setting the enterprise activation\n  // code to serve.\n  rpc Activate(ActivateRequest) returns (ActivateResponse) {}\n  rpc GetActivationCode(GetActivationCodeRequest) returns (GetActivationCodeResponse) {}\n\n  // DeleteAll deactivates the server and removes all data.\n  rpc DeleteAll(DeleteAllRequest) returns (DeleteAllResponse) {}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='// CRUD operations for the pachds registered with this server.\n  rpc AddCluster(AddClusterRequest) returns (AddClusterResponse) {}\n  rpc DeleteCluster(DeleteClusterRequest) returns (DeleteClusterResponse) {}\n  rpc ListClusters(ListClustersRequest) returns (ListClustersResponse) {}\n  rpc UpdateCluster(UpdateClusterRequest) returns (UpdateClusterResponse) {}\n\n  // Heartbeat is the RPC registered pachds make to the license server\n  // to communicate their status and fetch updates.\n  rpc Heartbeat(HeartbeatRequest) returns (HeartbeatResponse) {}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='// Lists all clusters available to user\n  rpc ListUserClusters(ListUserClustersRequest) returns (ListUserClustersResponse) {}\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='syntax = "proto3";\n\npackage identity_v2;', metadata={'source': 'protobufs/main.proto'}), Document(page_content='option go_package = "github.com/pachyderm/pachyderm/v2/src/identity";\n\nimport "google/protobuf/timestamp.proto";\nimport "google/protobuf/struct.proto";\nimport "gogoproto/gogo.proto";\n\nimport "protoextensions/log.proto";\n\n// User represents an IDP user that has authenticated via OIDC', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message User {\n  string email = 1;\n  google.protobuf.Timestamp last_authenticated = 2 [(gogoproto.moretags) = "db:\\"last_authenticated\\"", (gogoproto.stdtime) = true];\n}\n\n// IdentityServerConfig is the configuration for the identity web server.\n// When the configuration is changed the web server is reloaded automatically.\nmessage IdentityServerConfig {\n  string issuer = 1;\n  string id_token_expiry = 2 [(gogoproto.moretags) = "db:\\"id_token_expiry\\""];\n  string rotation_token_expiry = 3 [(gogoproto.moretags) = "db:\\"rotation_token_expiry\\""];\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message SetIdentityServerConfigRequest {\n  IdentityServerConfig config = 1;\n}\n\nmessage SetIdentityServerConfigResponse {}\n\n\nmessage GetIdentityServerConfigRequest {}\n\nmessage GetIdentityServerConfigResponse {\n  IdentityServerConfig config = 1;\n}\n\n// IDPConnector represents a connection to an identity provider', metadata={'source': 'protobufs/main.proto'}), Document(page_content="message IDPConnector {\n  // ID is the unique identifier for this connector.\n  string id = 1;\n\n  // Name is the human-readable identifier for this connector,\n  // which will be shown to end users when they're authenticating.\n  string name = 2;\n\n  // Type is the type of the IDP ex. `saml`, `oidc`, `github`.\n  string type = 3;\n\n  // ConfigVersion must be incremented every time a connector is\n  // updated, to avoid concurrent updates conflicting.\n  int64 configVersion = 4;", metadata={'source': 'protobufs/main.proto'}), Document(page_content='// This is left for backwards compatibility, but we want users to use the config defined below.\n  string jsonConfig = 5 [(log.mask) = true];\n\n  // Config is the configuration for the upstream IDP, which varies based on the type.\n  // We make the assumption that this is either yaml or JSON.\n  google.protobuf.Struct config = 6 [(log.mask) = true];\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message CreateIDPConnectorRequest {\n  IDPConnector connector = 1;\n}\n\nmessage CreateIDPConnectorResponse {}\n\nmessage UpdateIDPConnectorRequest {\n  IDPConnector connector = 1;\n}\n\nmessage UpdateIDPConnectorResponse {}\n\nmessage ListIDPConnectorsRequest {}\n\nmessage ListIDPConnectorsResponse {\n  repeated IDPConnector connectors = 1;\n}\n\nmessage GetIDPConnectorRequest {\n  string id = 1;\n}\n\nmessage GetIDPConnectorResponse {\n  IDPConnector connector = 1;\n}\n\nmessage DeleteIDPConnectorRequest {\n  string id = 1;\n}\n\nmessage DeleteIDPConnectorResponse {}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message DeleteIDPConnectorResponse {}\n\nmessage OIDCClient {\n  string id = 1;\n  repeated string redirect_uris = 2;\n  repeated string trusted_peers = 3;\n  string name = 4;\n  string secret = 5 [(log.mask) = true];\n}\n\nmessage CreateOIDCClientRequest {\n  OIDCClient client = 1;\n}\n\nmessage CreateOIDCClientResponse {\n  OIDCClient client = 1;\n}\n\nmessage GetOIDCClientRequest {\n  string id = 1;\n}\n\nmessage GetOIDCClientResponse {\n  OIDCClient client = 1;\n}\n\nmessage ListOIDCClientsRequest {}\n\nmessage ListOIDCClientsResponse {\n  repeated OIDCClient clients = 1;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message UpdateOIDCClientRequest {\n  OIDCClient client = 1;\n}\n\nmessage UpdateOIDCClientResponse {}\n\nmessage DeleteOIDCClientRequest {\n  string id = 1;\n}\n\nmessage DeleteOIDCClientResponse {}\n\nmessage DeleteAllRequest {}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message DeleteAllResponse {}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='service API {\n  rpc SetIdentityServerConfig(SetIdentityServerConfigRequest) returns (SetIdentityServerConfigResponse) {}\n  rpc GetIdentityServerConfig(GetIdentityServerConfigRequest) returns (GetIdentityServerConfigResponse) {}\n  rpc CreateIDPConnector(CreateIDPConnectorRequest) returns (CreateIDPConnectorResponse) {}\n  rpc UpdateIDPConnector(UpdateIDPConnectorRequest) returns (UpdateIDPConnectorResponse) {}\n  rpc ListIDPConnectors(ListIDPConnectorsRequest) returns (ListIDPConnectorsResponse) {}\n  rpc GetIDPConnector(GetIDPConnectorRequest) returns (GetIDPConnectorResponse) {}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='rpc DeleteIDPConnector(DeleteIDPConnectorRequest) returns (DeleteIDPConnectorResponse) {}\n  rpc CreateOIDCClient(CreateOIDCClientRequest) returns (CreateOIDCClientResponse) {}\n  rpc UpdateOIDCClient(UpdateOIDCClientRequest) returns (UpdateOIDCClientResponse) {}\n  rpc GetOIDCClient(GetOIDCClientRequest) returns (GetOIDCClientResponse) {}\n  rpc ListOIDCClients(ListOIDCClientsRequest) returns (ListOIDCClientsResponse) {}\n  rpc DeleteOIDCClient(DeleteOIDCClientRequest) returns (DeleteOIDCClientResponse) {}\n  rpc DeleteAll(DeleteAllRequest) returns (DeleteAllResponse) {}\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='syntax = "proto3";\n\npackage enterprise_v2;', metadata={'source': 'protobufs/main.proto'}), Document(page_content='option go_package = "github.com/pachyderm/pachyderm/v2/src/enterprise";\n\nimport "google/protobuf/timestamp.proto";\n\nimport "protoextensions/log.proto";\n\n// Enterprise data structures\n\n// LicenseRecord is the record we store in etcd for a Pachyderm enterprise\n// token that has been provided to a Pachyderm license server', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message LicenseRecord {\n  string activation_code = 1 [(log.half) = true];\n\n  google.protobuf.Timestamp expires = 2;\n}\n\n// EnterpriseConfig is the configuration we store for heartbeating\n// to the license server.', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message EnterpriseConfig {\n  // license_server is the address of the grpc license service\n  string license_server = 1;\n  // id is the unique identifier for this pachd, which is registered\n  // with the license service\n  string id = 2;\n  // secret is a shared secret between this pachd and the license service\n  string secret = 3;\n}\n\n// EnterpriseRecord is a protobuf we cache in etcd to store the\n// enterprise status.', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message EnterpriseRecord {\n  // license is the cached LicenseRecord retrieved from the most recent\n  // heartbeat to the license server.\n  LicenseRecord license = 1;\n\n  // last_heartbeat is the timestamp of the last successful heartbeat\n  // to the license server\n  google.protobuf.Timestamp last_heartbeat = 2;\n\n  // heartbeat_failed is set if the license is still valid, but\n  // the pachd is no longer registered with an enterprise server.\n  // This is the same as the expired state, where auth is locked\n  // but not disabled.\n  bool heartbeat_failed = 3;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='enum State {\n  NONE = 0;\n  ACTIVE = 1;\n  EXPIRED = 2;\n  HEARTBEAT_FAILED = 3;\n}\n\n// TokenInfo contains information about the currently active enterprise token', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message TokenInfo {\n  // expires indicates when the current token expires (unset if there is no\n  // current token)\n  google.protobuf.Timestamp expires = 1;\n}\n\n//// Enterprise Activation API\n\nmessage ActivateRequest {\n  string license_server = 1;\n  string id = 2;\n  string secret = 3 [(log.half) = true];\n}\nmessage ActivateResponse {}\n\nmessage GetStateRequest {}\n\nmessage GetStateResponse {\n  State state = 1;\n  TokenInfo info = 2;\n\n  // activation_code will always be an empty string,\n  // call GetEnterpriseCode to get the activation code\n  string activation_code = 3 [(log.half) = true];\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message GetActivationCodeRequest {}\n\nmessage GetActivationCodeResponse {\n  State state = 1;\n  TokenInfo info = 2;\n  string activation_code = 3 [(log.half) = true];\n}\n\n// Heartbeat in the enterprise service just triggers a heartbeat for\n// testing purposes. The RPC used to communicate with the license\n// service is defined in the license service.\nmessage HeartbeatRequest{}\nmessage HeartbeatResponse{}\n\nmessage DeactivateRequest{}\nmessage DeactivateResponse{}\n\nmessage PauseRequest{}\nmessage PauseResponse{}\n\nmessage UnpauseRequest{}\nmessage UnpauseResponse{}\n\nmessage PauseStatusRequest{}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message PauseStatusResponse{\n  enum PauseStatus {\n    UNPAUSED = 0;\n    PARTIALLY_PAUSED = 1;\n    PAUSED = 2;\n  }\n  PauseStatus status = 1;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='service API {\n  // Provide a Pachyderm enterprise token, enabling Pachyderm enterprise\n  // features, such as the Pachyderm Dashboard and Auth system\n  rpc Activate(ActivateRequest) returns (ActivateResponse) {}\n  rpc GetState(GetStateRequest) returns (GetStateResponse) {}\n  rpc GetActivationCode(GetActivationCodeRequest) returns (GetActivationCodeResponse) {}\n\n  // Heartbeat is used in testing to trigger a heartbeat on demand. Normally this happens\n  // on a timer.\n  rpc Heartbeat(HeartbeatRequest) returns (HeartbeatResponse) {}', metadata={'source': 'protobufs/main.proto'}), Document(page_content="// Deactivate removes a cluster's enterprise activation\n  // token and sets its enterprise state to NONE.\n  rpc Deactivate(DeactivateRequest) returns (DeactivateResponse) {}\n\n  // Pause pauses the cluster.\n  rpc Pause(PauseRequest) returns (PauseResponse) {}\n  // Unpause unpauses the cluser.\n  rpc Unpause(UnpauseRequest) returns (UnpauseResponse) {}\n  rpc PauseStatus(PauseStatusRequest) returns (PauseStatusResponse) {}\n}", metadata={'source': 'protobufs/main.proto'}), Document(page_content='syntax = "proto3";\n\npackage auth_v2;', metadata={'source': 'protobufs/main.proto'}), Document(page_content='option go_package = "github.com/pachyderm/pachyderm/v2/src/auth";\n\nimport "gogoproto/gogo.proto";\nimport "google/protobuf/timestamp.proto";', metadata={'source': 'protobufs/main.proto'}), Document(page_content='import "protoextensions/log.proto";', metadata={'source': 'protobufs/main.proto'}), Document(page_content='/* A note on users\n *\n * In Pachyderm, usernames are structured strings. This makes both\n * our API and our data model more flexible (at the loss of some type safety).\n * Basically, anywhere that Pachyderm refers to a subject (i.e. TokenInfo) or\n * principal (ACL, the \'admins\' collection), that username will have some\n * structured prefix.\n *\n * Note that externally-facing principals ({Get,Set}{Scope,ACL}, ModifyAdmins,\n * ListAdmins) will have their own conventions\n *\n * The current user formats are:\n * 1) Users synced from an identity provider:\n *      "user:username"', metadata={'source': 'protobufs/main.proto'}), Document(page_content='*      "user:username"\n * 2) Pachyderm robot users:\n *      "robot:robot_user_1"\n * 3) Pachyderm pipelines:\n *      "pipeline:terasort"\n */', metadata={'source': 'protobufs/main.proto'}), Document(page_content='//// Activation API\n\n// ActivateRequest enables authentication on the cluster. It issues an auth token\n// with no expiration for the irrevocable admin user `pach:root`.', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message ActivateRequest {\n  // If set, this token is used as the root user login token. Otherwise the root token\n  // is randomly generated and returned in the response.\n  string root_token = 1 [(log.mask) = true];\n}\n\nmessage ActivateResponse {\n  // pach_token authenticates the caller with Pachyderm (if you want to perform\n  // Pachyderm operations after auth has been activated as themselves, you must\n  // present this token along with your regular request)\n  string pach_token = 1 [(log.mask) = true];\n}\n\nmessage DeactivateRequest {}\nmessage DeactivateResponse {}', metadata={'source': 'protobufs/main.proto'}), Document(page_content="message DeactivateRequest {}\nmessage DeactivateResponse {}\n\nmessage RotateRootTokenRequest {\n  // root_token is used as the new root token value. If it's unset, then a token will be auto-generated.\n  string root_token = 1 [(log.mask) = true];\n}\n\nmessage RotateRootTokenResponse {\n  string root_token = 1 [(log.mask) = true];\n}\n\n// Configure Pachyderm's auth system with an OIDC provider", metadata={'source': 'protobufs/main.proto'}), Document(page_content='message OIDCConfig{\n  string issuer = 1;\n  string client_id = 2 [(gogoproto.customname) = "ClientID"];\n  string client_secret = 3 [(log.mask) = true];\n  string redirect_uri = 4 [(gogoproto.customname) = "RedirectURI"];\n  repeated string scopes = 5;\n  bool require_email_verified = 6;\n\n // localhost_issuer ignores the contents of the issuer claim and makes all\n // OIDC requests to the embedded OIDC provider. This is necessary to support\n // some network configurations like Minikube.\n bool localhost_issuer = 7;', metadata={'source': 'protobufs/main.proto'}), Document(page_content="// user_accessible_issuer_host can be set to override the host used\n  // in the OAuth2 authorization URL in case the OIDC issuer isn't\n  // accessible outside the cluster. This requires a fully formed URL with scheme of either http or https.\n  // This is necessary to support some configurations like Minikube.\n  string user_accessible_issuer_host = 8;\n}", metadata={'source': 'protobufs/main.proto'}), Document(page_content="message GetConfigurationRequest {}\nmessage GetConfigurationResponse {\n  OIDCConfig configuration = 1;\n}\nmessage SetConfigurationRequest {\n  OIDCConfig configuration = 1;\n}\nmessage SetConfigurationResponse {}\n\n//// Authentication data structures\n\n// TokenInfo is the 'value' of an auth token 'key' in the 'tokens' collection", metadata={'source': 'protobufs/main.proto'}), Document(page_content='message TokenInfo {\n  // Subject (i.e. Pachyderm account) that a given token authorizes.\n  // See the note at the top of the doc for an explanation of subject structure.\n  string subject = 1;\n  google.protobuf.Timestamp expiration = 2 [(gogoproto.moretags) = "db:\\"expiration\\"", (gogoproto.stdtime) = true];\n  string hashed_token = 3 [(gogoproto.moretags) = "db:\\"token_hash\\""];\n}\n\n//// Authentication API', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message AuthenticateRequest {\n  // Exactly one of \'id_token\' or \'one_time_password\' must be set:\n\n  // This is the session state that Pachyderm creates in order to keep track of\n  // information related to the current OIDC session.\n  string oidc_state = 1 [(gogoproto.customname) = "OIDCState", (log.half) = true];\n\n  // This is an ID Token issued by the OIDC provider.\n  string id_token = 2 [(log.half) = true];\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message AuthenticateResponse {\n  // pach_token authenticates the caller with Pachyderm (if you want to perform\n  // Pachyderm operations after auth has been activated as themselves, you must\n  // present this token along with your regular request)\n  string pach_token = 1 [(log.mask) = true];\n}\n\nmessage WhoAmIRequest {}\n\nmessage WhoAmIResponse {\n  string username = 1;\n  google.protobuf.Timestamp expiration = 2 [(gogoproto.moretags) = "db:\\"expiration\\"", (gogoproto.stdtime) = true];\n}\n\nmessage GetRolesForPermissionRequest {\n  Permission permission = 1;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message GetRolesForPermissionResponse {\n  repeated Role roles = 1;\n}\n\n//// Authorization data structures\n\n// Roles represents the set of roles a principal has\nmessage Roles {\n  map<string, bool> roles = 1;\n}\n\n// RoleBinding represents the set of roles principals have on a given Resource', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message RoleBinding {\n  // principal -> roles. All principal names include the structured prefix indicating their type.\n  map<string, Roles> entries = 1;\n}\n\n// Permission represents the ability to perform a given operation on a Resource', metadata={'source': 'protobufs/main.proto'}), Document(page_content='enum Permission {\n  PERMISSION_UNKNOWN = 0;\n\n  CLUSTER_MODIFY_BINDINGS                          = 100;\n  CLUSTER_GET_BINDINGS                             = 101;\n  CLUSTER_GET_PACHD_LOGS                           = 148;\n  CLUSTER_GET_LOKI_LOGS                            = 150;', metadata={'source': 'protobufs/main.proto'}), Document(page_content='CLUSTER_AUTH_ACTIVATE                            = 102;\n  CLUSTER_AUTH_DEACTIVATE                          = 103;\n  CLUSTER_AUTH_GET_CONFIG                          = 104;\n  CLUSTER_AUTH_SET_CONFIG                          = 105;\n  CLUSTER_AUTH_GET_ROBOT_TOKEN                     = 139;\n  CLUSTER_AUTH_MODIFY_GROUP_MEMBERS                = 109;\n  CLUSTER_AUTH_GET_GROUPS                          = 110;\n  CLUSTER_AUTH_GET_GROUP_USERS                     = 111;\n  CLUSTER_AUTH_EXTRACT_TOKENS                      = 112;\n  CLUSTER_AUTH_RESTORE_TOKEN                       = 113;', metadata={'source': 'protobufs/main.proto'}), Document(page_content='CLUSTER_AUTH_RESTORE_TOKEN                       = 113;\n  CLUSTER_AUTH_GET_PERMISSIONS_FOR_PRINCIPAL       = 141;\n  CLUSTER_AUTH_DELETE_EXPIRED_TOKENS               = 140;\n  CLUSTER_AUTH_REVOKE_USER_TOKENS                  = 142;\n  CLUSTER_AUTH_ROTATE_ROOT_TOKEN                   = 147;', metadata={'source': 'protobufs/main.proto'}), Document(page_content='CLUSTER_ENTERPRISE_ACTIVATE            = 114;\n  CLUSTER_ENTERPRISE_HEARTBEAT           = 115;\n  CLUSTER_ENTERPRISE_GET_CODE            = 116;\n  CLUSTER_ENTERPRISE_DEACTIVATE          = 117;\n  CLUSTER_ENTERPRISE_PAUSE               = 149;', metadata={'source': 'protobufs/main.proto'}), Document(page_content='CLUSTER_IDENTITY_SET_CONFIG            = 118;\n  CLUSTER_IDENTITY_GET_CONFIG            = 119;\n  CLUSTER_IDENTITY_CREATE_IDP            = 120;\n  CLUSTER_IDENTITY_UPDATE_IDP            = 121;\n  CLUSTER_IDENTITY_LIST_IDPS             = 122;\n  CLUSTER_IDENTITY_GET_IDP               = 123;\n  CLUSTER_IDENTITY_DELETE_IDP            = 124;\n  CLUSTER_IDENTITY_CREATE_OIDC_CLIENT    = 125;\n  CLUSTER_IDENTITY_UPDATE_OIDC_CLIENT    = 126;\n  CLUSTER_IDENTITY_LIST_OIDC_CLIENTS     = 127;\n  CLUSTER_IDENTITY_GET_OIDC_CLIENT       = 128;\n  CLUSTER_IDENTITY_DELETE_OIDC_CLIENT    = 129;', metadata={'source': 'protobufs/main.proto'}), Document(page_content='CLUSTER_DEBUG_DUMP                     = 131;\n\n  CLUSTER_LICENSE_ACTIVATE               = 132;\n  CLUSTER_LICENSE_GET_CODE               = 133;\n  CLUSTER_LICENSE_ADD_CLUSTER            = 134;\n  CLUSTER_LICENSE_UPDATE_CLUSTER         = 135;\n  CLUSTER_LICENSE_DELETE_CLUSTER         = 136;\n  CLUSTER_LICENSE_LIST_CLUSTERS          = 137;\n\n  // TODO(actgardner): Make k8s secrets into nouns and add an Update RPC\n  CLUSTER_CREATE_SECRET  = 143;\n  CLUSTER_LIST_SECRETS   = 144;\n  SECRET_DELETE          = 145;\n  SECRET_INSPECT         = 146;\n\n  CLUSTER_DELETE_ALL             = 138;', metadata={'source': 'protobufs/main.proto'}), Document(page_content='CLUSTER_DELETE_ALL             = 138;\n\n  REPO_READ                   = 200;\n  REPO_WRITE                  = 201;\n  REPO_MODIFY_BINDINGS        = 202;\n  REPO_DELETE                 = 203;\n  REPO_INSPECT_COMMIT         = 204;\n  REPO_LIST_COMMIT            = 205;\n  REPO_DELETE_COMMIT          = 206;\n  REPO_CREATE_BRANCH          = 207;\n  REPO_LIST_BRANCH            = 208;\n  REPO_DELETE_BRANCH          = 209;\n  REPO_INSPECT_FILE           = 210;\n  REPO_LIST_FILE              = 211;\n  REPO_ADD_PIPELINE_READER    = 212;\n  REPO_REMOVE_PIPELINE_READER = 213;\n  REPO_ADD_PIPELINE_WRITER    = 214;', metadata={'source': 'protobufs/main.proto'}), Document(page_content='PIPELINE_LIST_JOB     = 301;\n\n  PROJECT_CREATE = 400;\n  PROJECT_DELETE = 401;\n  PROJECT_LIST_REPO = 402;\n  PROJECT_CREATE_REPO = 403;\n  PROJECT_MODIFY_BINDINGS = 404;\n}\n\n// ResourceType represents the type of a Resource', metadata={'source': 'protobufs/main.proto'}), Document(page_content='enum ResourceType {\n  RESOURCE_TYPE_UNKNOWN = 0;\n  CLUSTER   = 1;\n  REPO      = 2;\n  SPEC_REPO = 3;\n  PROJECT   = 4;\n}\n\n// Resource represents any resource that has role-bindings in the system', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message Resource {\n  ResourceType type = 1;\n  string name = 2;\n}\n\nmessage Users {\n  map<string, bool> usernames = 1;\n}\n\nmessage Groups {\n  map<string, bool> groups = 1;\n}\n\nmessage Role {\n  string name = 1;\n  repeated Permission permissions = 2;\n  repeated ResourceType resource_types = 3;\n}\n\n//// Authorization API\n\nmessage AuthorizeRequest {\n  Resource resource = 1;\n\n  // permissions are the operations the caller is attempting to perform\n  repeated Permission permissions = 2;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content="message AuthorizeResponse {\n  // authorized is true if the caller has the require permissions\n  bool authorized = 1;\n\n  // satisfied is the set of permission that the principal has\n  repeated Permission satisfied = 2;\n\n  // missing is the set of permissions that the principal lacks\n  repeated Permission missing = 3;\n\n  // principal is the principal the request was evaluated for\n  string principal = 4;\n}\n\n// GetPermissions evaluates the current user's permissions on a resource", metadata={'source': 'protobufs/main.proto'}), Document(page_content="message GetPermissionsRequest {\n  Resource resource = 1;\n}\n\n// GetPermissionsForPrincipal evaluates an arbitrary principal's permissions\n// on a resource\nmessage GetPermissionsForPrincipalRequest {\n  Resource resource = 1;\n\n  string principal = 2;\n}\n\nmessage GetPermissionsResponse {\n  // permissions is the set of permissions the principal has\n  repeated Permission permissions = 1;\n\n  // roles is the set of roles the principal has\n  repeated string roles = 2;\n}", metadata={'source': 'protobufs/main.proto'}), Document(page_content='message ModifyRoleBindingRequest {\n  // resource is the resource to modify the role bindings on\n  Resource resource = 1;\n\n  // principal is the principal to modify the roles binding for\n  string principal = 2;\n\n  // roles is the set of roles for principal - an empty list\n  // removes all role bindings\n  repeated string roles = 3;\n}\n\nmessage ModifyRoleBindingResponse {}\n\nmessage GetRoleBindingRequest {\n  Resource resource = 1;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message GetRoleBindingResponse {\n  RoleBinding binding = 1;\n}\n\n//////////////////////////////\n//// OIDC Data Structures ////\n//////////////////////////////', metadata={'source': 'protobufs/main.proto'}), Document(page_content="// SessionInfo stores information associated with one OIDC authentication\n// session (i.e. a single instance of a single user logging in). Sessions are\n// short-lived and stored in the 'oidc-authns' collection, keyed by the OIDC\n// 'state' token (30-character CSPRNG-generated string). 'GetOIDCLogin'\n// generates and inserts entries, then /authorization-code/callback retrieves\n// an access token from the ID provider and uses it to retrive the caller's\n// email and store it in 'email', and finally Authorize() returns a Pachyderm", metadata={'source': 'protobufs/main.proto'}), Document(page_content='// token identified with that email address as a subject in Pachyderm.', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message SessionInfo {\n  // nonce is used by /authorization-code/callback to validate session\n  // continuity with the IdP after a user has arrived there from GetOIDCLogin().\n  // This is a 30-character CSPRNG-generated string.\n  string nonce = 1 [(log.half) = true];\n  // email contains the email adddress associated with a user in their OIDC ID\n  // provider. Currently users are identified with their email address rather\n  // than their OIDC subject identifier to make switching between OIDC ID\n  // providers easier for users, and to make user identities more easily', metadata={'source': 'protobufs/main.proto'}), Document(page_content="// comprehensible in Pachyderm. The OIDC spec doesn't require that users'\n  // emails be present or unique, but we think this will be preferable in\n  // practice.\n  string email = 2;\n  // conversion_err indicates whether an error was encountered while exchanging\n  // an auth code for an access token, or while obtaining a user's email (in\n  // /authorization-code/callback). Storing the error state here allows any\n  // sibling calls to Authenticate() (i.e. using the same OIDC state token) to\n  // notify their caller that an error has occurred. We avoid passing the caller", metadata={'source': 'protobufs/main.proto'}), Document(page_content='// any details of the error (which are logged by Pachyderm) to avoid giving\n  // information to a user who has network access to Pachyderm but not an\n  // account in the OIDC provider.\n  bool conversion_err = 3;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='//// OIDC API', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message GetOIDCLoginRequest {\n}\n\nmessage GetOIDCLoginResponse {\n  // The login URL generated for the OIDC object\n  string login_url = 1 [(gogoproto.customname) = "LoginURL", (log.half) = true];\n  string state = 2 [(log.half) = true];\n}\n\n// Robot token API (TODO: add access controls)\n\nmessage GetRobotTokenRequest {\n  // The returned token will allow the caller to access resources as this\n  // robot user\n  string robot = 1;\n\n  // ttl indicates the requested (approximate) remaining lifetime of this token,\n  // in seconds\n  int64 ttl = 2 [(gogoproto.customname) = "TTL"];\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message GetRobotTokenResponse {\n  // A new auth token for the requested robot\n  string token = 1 [(log.mask) = true];\n}\n\nmessage RevokeAuthTokenRequest {\n  string token = 1 [(log.half) = true];\n}\n\nmessage RevokeAuthTokenResponse {\n  int64 number = 1;\n}\n\nmessage SetGroupsForUserRequest {\n  string username = 1;\n  repeated string groups = 2;\n}\n\nmessage SetGroupsForUserResponse {}\n\nmessage ModifyMembersRequest {\n  string group = 1;\n  repeated string add = 2;\n  repeated string remove = 3;\n}\n\nmessage ModifyMembersResponse {}\n\nmessage GetGroupsRequest {}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message GetGroupsRequest {}\n\nmessage GetGroupsForPrincipalRequest {\n  string principal = 1;\n}\n\nmessage GetGroupsResponse {\n  repeated string groups = 1;\n}\n\nmessage GetUsersRequest {\n  string group = 1;\n}\n\nmessage GetUsersResponse {\n  repeated string usernames = 1;\n}\n\n// ExtractAuthTokens returns all the hashed robot tokens that have been issued.\n// User tokens are not extracted as they can be recreated by logging in.\nmessage ExtractAuthTokensRequest {}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message ExtractAuthTokensRequest {}\n\nmessage ExtractAuthTokensResponse {\n  repeated TokenInfo tokens = 1;\n}\n\n// RestoreAuthToken inserts a hashed token that has previously been extracted.\nmessage RestoreAuthTokenRequest {\n  TokenInfo token = 1;\n}\n\nmessage RestoreAuthTokenResponse {}\n\nmessage RevokeAuthTokensForUserRequest {\n  string username = 1;\n}\n\nmessage RevokeAuthTokensForUserResponse {\n  int64 number = 1;\n}\n\nmessage DeleteExpiredAuthTokensRequest {}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message DeleteExpiredAuthTokensResponse {}', metadata={'source': 'protobufs/main.proto'}), Document(page_content="service API {\n  // Activate/Deactivate the auth API. 'Activate' sets an initial set of admins\n  // for the Pachyderm cluster, and 'Deactivate' removes all ACLs, tokens, and\n  // admins from the Pachyderm cluster, making all data publicly accessable\n  rpc Activate(ActivateRequest) returns (ActivateResponse) {}\n  rpc Deactivate(DeactivateRequest) returns (DeactivateResponse) {}\n\n  rpc GetConfiguration(GetConfigurationRequest) returns (GetConfigurationResponse) {}\n  rpc SetConfiguration(SetConfigurationRequest) returns (SetConfigurationResponse) {}", metadata={'source': 'protobufs/main.proto'}), Document(page_content='rpc Authenticate(AuthenticateRequest) returns (AuthenticateResponse) {}\n  rpc Authorize(AuthorizeRequest) returns (AuthorizeResponse) {}\n  rpc GetPermissions(GetPermissionsRequest) returns (GetPermissionsResponse) {}\n  rpc GetPermissionsForPrincipal(GetPermissionsForPrincipalRequest) returns (GetPermissionsResponse) {}\n  rpc WhoAmI(WhoAmIRequest) returns (WhoAmIResponse) {}\n  rpc GetRolesForPermission(GetRolesForPermissionRequest) returns (GetRolesForPermissionResponse) {}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='rpc ModifyRoleBinding(ModifyRoleBindingRequest) returns (ModifyRoleBindingResponse) {}\n  rpc GetRoleBinding(GetRoleBindingRequest) returns (GetRoleBindingResponse) {}\n\n  rpc GetOIDCLogin(GetOIDCLoginRequest) returns (GetOIDCLoginResponse) {}\n\n  rpc GetRobotToken(GetRobotTokenRequest) returns (GetRobotTokenResponse) {}\n  rpc RevokeAuthToken(RevokeAuthTokenRequest) returns (RevokeAuthTokenResponse) {}\n  rpc RevokeAuthTokensForUser(RevokeAuthTokensForUserRequest) returns (RevokeAuthTokensForUserResponse) {}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='rpc SetGroupsForUser(SetGroupsForUserRequest) returns (SetGroupsForUserResponse) {}\n  rpc ModifyMembers(ModifyMembersRequest) returns (ModifyMembersResponse) {}\n  rpc GetGroups(GetGroupsRequest) returns (GetGroupsResponse) {}\n  rpc GetGroupsForPrincipal(GetGroupsForPrincipalRequest) returns (GetGroupsResponse) {}\n  rpc GetUsers(GetUsersRequest) returns (GetUsersResponse) {}\n\n  rpc ExtractAuthTokens(ExtractAuthTokensRequest) returns (ExtractAuthTokensResponse) {}\n  rpc RestoreAuthToken(RestoreAuthTokenRequest) returns (RestoreAuthTokenResponse) {}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='rpc DeleteExpiredAuthTokens(DeleteExpiredAuthTokensRequest) returns (DeleteExpiredAuthTokensResponse) {}\n  rpc RotateRootToken(RotateRootTokenRequest) returns (RotateRootTokenResponse) {}\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='syntax = "proto3";\n\npackage admin_v2;', metadata={'source': 'protobufs/main.proto'}), Document(page_content='option go_package = "github.com/pachyderm/pachyderm/v2/src/admin";\n\nimport "gogoproto/gogo.proto";\nimport "version/versionpb/version.proto";', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message ClusterInfo {\n  string id = 1 [(gogoproto.customname) = "ID"];\n  string deployment_id = 2 [(gogoproto.customname) = "DeploymentID"];\n\n  bool version_warnings_ok = 3; // Let the client detect a server that can\'t generate warnings.\n  repeated string version_warnings = 4; // Warnings about version skew.\n\n  string proxy_host = 5;\n  bool proxy_tls = 6;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message InspectClusterRequest {\n  versionpb_v2.Version client_version = 1;\n}\n\nservice API {\n  rpc InspectCluster(InspectClusterRequest) returns (ClusterInfo) {}\n}\n\nsyntax = "proto3";\n\npackage metrics;\noption go_package = "github.com/pachyderm/pachyderm/v2/src/internal/metrics";\n\nimport "gogoproto/gogo.proto";', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message Metrics {\n    string cluster_id              =  1 [(gogoproto.customname) = "ClusterID"];\n    string pod_id                  =  2 [(gogoproto.customname) = "PodID"];\n    int64 nodes                    =  3;\n    string version                 =  4;\n    int64 repos                    =  5; // Number of repos\n    int64 commits                  =  6; // Number of commits -- not used\n    int64 files                    =  7; // Number of files -- not used\n    uint64 bytes                   =  8; // Number of bytes in all repos\n    int64 jobs                     =  9; // Number of jobs', metadata={'source': 'protobufs/main.proto'}), Document(page_content='int64 jobs                     =  9; // Number of jobs\n    int64 pipelines                = 10; // Number of pipelines in the cluster -- not the same as DAG\n    int64 archived_commits         = 11; // Number of archived commit -- not used\n    int64 cancelled_commits        = 12; // Number of cancelled commits -- not used\n    string activation_code         = 13; // Activation code\n    uint64 max_branches            = 14; // Max branches in across all the repos\n    int64 pps_spout                = 15; // Number of spout pipelines', metadata={'source': 'protobufs/main.proto'}), Document(page_content='int64 pps_spout_service        = 16; // Number of spout services\n    reserved 17; // int64 pps_build\n    int64 cfg_egress               = 18; // Number of pipelines with Egress configured\n    int64 cfg_standby              = 19; // Number of pipelines with Standby congigured\n    int64 cfg_s3gateway            = 20; // Number of pipelines with S3 Gateway configured\n    int64 cfg_services             = 21; // Number of pipelines with services configured\n    int64 cfg_errcmd               = 22; // Number of pipelines with error cmd set', metadata={'source': 'protobufs/main.proto'}), Document(page_content='int64 cfg_tfjob                = 24; // Number of pipelines with TFJobs configured\n    int64 input_group              = 25; // Number of pipelines with group inputs\n    int64 input_join               = 26; // Number of pipelines with join inputs\n    int64 input_cross              = 27; // Number of pipelines with cross inputs\n    int64 input_union              = 28; // Number of pipelines with union inputs\n    int64 input_cron               = 29; // Number of pipelines with cron inputs\n    int64 input_git                = 30; // Number of pipelines with git inputs', metadata={'source': 'protobufs/main.proto'}), Document(page_content='int64 input_pfs                = 31; // Number of pfs inputs\n    int64 input_commit             = 32; // Number of pfs inputs with commits\n    int64 input_join_on            = 33; // Number of pfs inputs with join_on\n    int64 input_outer_join         = 34; // Number of pipelines with outer joins\n    int64 input_lazy               = 35; // Number of pipelines with lazy set\n    int64 input_empty_files        = 36; // Number of pipelines with empty files set\n    int64 input_s3                 = 37; // Number of pipelines with S3 input', metadata={'source': 'protobufs/main.proto'}), Document(page_content='int64 input_trigger            = 38; // Number of pipelines with triggers set\n    float resource_cpu_req         = 39; // Total CPU request across all pipelines\n    float resource_cpu_req_max     = 40; // Max CPU resource requests set\n    string resource_mem_req        = 41; // Sting of memory requests set across all pipelines\n    int64 resource_gpu_req         = 42; // Total GPU requests across all pipelines\n    int64 resource_gpu_req_max     = 43; // Max GPU request across all pipelines\n    string resource_disk_req       = 44; // String of disk requests set across all pipelines', metadata={'source': 'protobufs/main.proto'}), Document(page_content='float resource_cpu_limit       = 45; // Total CPU limits set across all pipelines\n    float resource_cpu_limit_max   = 46; // Max CPU limit set\n    string resource_mem_limit      = 47; // String of memory limits set\n    int64 resource_gpu_limit       = 48; // Number of pipelines with\n    int64 resource_gpu_limit_max   = 49; // Max GPU limit set\n    string resource_disk_limit     = 50; // String of disk limits set across all pipelines\n    uint64 max_parallelism         = 51; // Max parallelism set\n    uint64 min_parallelism         = 52; // Min parallelism set', metadata={'source': 'protobufs/main.proto'}), Document(page_content='uint64 num_parallelism         = 53; // Number of pipelines with parallelism set\n    int64 enterprise_failures      = 54; // Number of times a command has failed due to an enterprise check\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='syntax = "proto3";\n\npackage extended;', metadata={'source': 'protobufs/main.proto'}), Document(page_content='option go_package = "github.com/pachyderm/pachyderm/v2/src/internal/tracing/extended";\n\n// TraceProto contains information identifying a Jaeger trace. It\'s used to\n// propagate traces that follow the lifetime of a long operation (e.g. creating\n// a pipeline or running a job), and which live longer than any single RPC.', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message TraceProto {\n  // serialized_trace contains the info identifying a trace in Jaeger (a\n  // (trace ID, span ID, sampled) tuple, basically)\n  map<string, string> serialized_trace = 1;\n\n  string project = 3;\n  // pipeline specifies the target pipeline of this trace; this would be set for\n  // a trace created by \'pachctl create-pipeline\' or \'pachctl update-pipeline\'\n  // and would include the kubernetes RPCs involved in creating a pipeline\n  string pipeline = 2;\n}\n\nsyntax = "proto3";\n\npackage common;', metadata={'source': 'protobufs/main.proto'}), Document(page_content='option go_package = "github.com/pachyderm/pachyderm/v2/src/internal/collection";\n\nimport "gogoproto/gogo.proto";', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message TestItem {\n  string id = 1 [(gogoproto.customname) = "ID"];\n  string value = 2;\n  string data = 3;\n}\n\nsyntax = "proto3";\n\npackage ppsload;\noption go_package = "github.com/pachyderm/pachyderm/v2/src/internal/ppsload";\n\nimport "pfs/pfs.proto";', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message State {\n  pfs_v2.Branch branch = 1;\n  string pfs_state_id = 2;\n}\n\nsyntax = "proto3";\n\npackage config_v2;', metadata={'source': 'protobufs/main.proto'}), Document(page_content='option go_package = "github.com/pachyderm/pachyderm/v2/src/internal/config";', metadata={'source': 'protobufs/main.proto'}), Document(page_content='import "gogoproto/gogo.proto";\n\n// Config specifies the pachyderm config that is read and interpreted by the\n// pachctl command-line tool. Right now, this is stored at\n// $HOME/.pachyderm/config.\n//\n// Different versions of the pachyderm config are specified as subfields of this\n// message (this allows us to make significant changes to the config structure\n// without breaking existing users by defining a new config version).\n//\n// These structures are stored in a JSON format, so it should be safe to modify\n// fields as long as compatibility is ensured with previous versions.', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message Config {\n    string user_id = 1 [(gogoproto.customname) = "UserID"];\n\n    // Configuration options. Exactly one of these fields should be set\n    // (depending on which version of the config is being used)\n    ConfigV1 v1 = 2;\n    ConfigV2 v2 = 3;\n}\n\n// ConfigV1 specifies v1 of the pachyderm config (June 30 2017 - June 2019)', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message ConfigV1 {\n    // A host:port pointing pachd at a pachyderm cluster.\n    string pachd_address = 1;\n\n    // Trusted root certificates (overrides installed certificates), formatted\n    // as base64-encoded PEM\n    string server_cas = 2 [(gogoproto.customname) = "ServerCAs"];\n\n    // A secret token identifying the current pachctl user within their\n    // pachyderm cluster. This is included in all RPCs sent by pachctl, and used\n    // to determine if pachctl actions are authorized.\n    string session_token = 3;', metadata={'source': 'protobufs/main.proto'}), Document(page_content='// The currently active transaction for batching together pachctl commands.\n    // This can be set or cleared via many of the `pachctl * transaction` commands.\n    // This is the ID of the transaction object stored in the pachyderm etcd.\n    string active_transaction = 4;\n}\n\n// ConfigV2 specifies v2 of the pachyderm config (June 2019 - present)', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message ConfigV2 {\n    string active_context = 1;\n    string active_enterprise_context = 2;\n    map<string, Context> contexts = 3;\n    bool metrics = 4;\n    int64 max_shell_completions = 5;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message Context {\n    // Where this context came from\n    ContextSource source = 1;\n\n    // The hostname or IP address pointing pachd at a pachyderm cluster.\n    string pachd_address = 2;\n\n    // Trusted root certificates (overrides installed certificates), formatted\n    // as base64-encoded PEM.\n    string server_cas = 3 [(gogoproto.customname) = "ServerCAs"];', metadata={'source': 'protobufs/main.proto'}), Document(page_content='// A secret token identifying the current pachctl user within their\n    // pachyderm cluster. This is included in all RPCs sent by pachctl, and used\n    // to determine if pachctl actions are authorized.\n    string session_token = 4;\n\n    // The currently active transaction for batching together pachctl commands.\n    // This can be set or cleared via many of the `pachctl * transaction` commands.\n    // This is the ID of the transaction object stored in the pachyderm etcd.\n    string active_transaction = 5;', metadata={'source': 'protobufs/main.proto'}), Document(page_content='// The k8s cluster name - used to construct a k8s context.\n    string cluster_name = 6;\n\n    // The k8s auth info - used to construct a k8s context.\n    string auth_info = 7;\n\n    // The k8s namespace - used to construct a k8s context.\n    string namespace = 8;\n\n    // A mapping of service -> port number, when port forwarding is\n    // running for this context.\n    map<string, uint32> port_forwarders = 9;', metadata={'source': 'protobufs/main.proto'}), Document(page_content='// A unique ID for the cluster deployment. At client initialization time,\n    // we ensure this is the same as what the cluster reports back, to prevent\n    // us from connecting to the wrong cluster.\n    string cluster_deployment_id = 10 [(gogoproto.customname) = "ClusterDeploymentID"];\n\n    // A boolean that records whether the context points at an enterprise server.\n    // If false, the context points at a stand-alone pachd.\n    bool enterprise_server = 11;\n\n    // The current project.\n    string project = 12;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='enum ContextSource {\n    NONE = 0;\n    CONFIG_V1 = 1;\n    HUB = 2;\n    IMPORTED = 3;\n}\n\nsyntax = "proto3";\n\npackage fileset;\noption go_package = "github.com/pachyderm/pachyderm/v2/src/internal/storage/fileset";\n\nimport "internal/storage/fileset/index/index.proto";', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message Metadata {\n  oneof value {\n    Primitive primitive = 1;\n    Composite composite = 2;\n  }\n}\n\nmessage Composite {\n  repeated string layers = 1;\n}\n\nmessage Primitive {\n  index.Index deletive = 1;\n  index.Index additive = 2;\n  int64 size_bytes = 3;\n}\n\nmessage TestCacheValue {\n  string file_set_id = 1;\n}\n\nsyntax = "proto3";\n\npackage index;\noption go_package = "github.com/pachyderm/pachyderm/v2/src/internal/storage/fileset/index";\n\nimport "internal/storage/chunk/chunk.proto";\n\n// Index stores an index to and metadata about a range of files or a file.', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message Index {\n  string path = 1;\n  // NOTE: range and file are mutually exclusive.\n  Range range = 2;\n  File file = 3;\n  // NOTE: num_files and size_bytes did not exist in older versions of 2.x, so\n  // they will not be set.\n  int64 num_files = 4;\n  int64 size_bytes = 5;\n}\n\nmessage Range {\n  int64 offset = 1;\n  string last_path = 2;\n  chunk.DataRef chunk_ref = 3;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message File {\n  string datum = 1;\n  repeated chunk.DataRef data_refs = 2;\n}\n\nsyntax = "proto3";\n\npackage chunk;\noption go_package = "github.com/pachyderm/pachyderm/v2/src/internal/storage/chunk";\n\n// DataRef is a reference to data within a chunk.', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message DataRef {\n  // The chunk the referenced data is located in.\n  Ref ref = 1;\n  // The hash of the data being referenced.\n  bytes hash = 2;\n  // The offset and size used for accessing the data within the chunk.\n  int64 offset_bytes = 3;\n  int64 size_bytes = 4;\n}\n\nenum CompressionAlgo {\n  NONE = 0;\n  GZIP_BEST_SPEED = 1;  \n}\n\nenum EncryptionAlgo {\n  ENCRYPTION_ALGO_UNKNOWN = 0;\n  CHACHA20 = 1;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message Ref {\n  bytes id = 1;\n  int64 size_bytes = 2;\n  bool edge = 3;\n\n  bytes dek = 4;\n  EncryptionAlgo encryption_algo = 5;\n  CompressionAlgo compression_algo = 6;\n}\n\nsyntax = "proto3";\n\npackage task;\noption go_package = "github.com/pachyderm/pachyderm/v2/src/internal/task";\n\nimport "gogoproto/gogo.proto";\nimport "google/protobuf/any.proto";\n\nenum State {\n  STATE_UNKNOWN = 0;\n  RUNNING = 1;\n  SUCCESS = 2;\n  FAILURE = 3;\n}\n\nmessage Group {}\n\n// TODO: Consider splitting this up into separate structures for each state in a oneof.', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message Task {\n  string id = 1 [(gogoproto.customname) = "ID"];\n  State state = 2;\n  google.protobuf.Any input = 3;\n  google.protobuf.Any output = 4;\n  string reason = 5;\n  int64 index = 6;\n}\n\nmessage Claim {}\n\nmessage TestTask {\n  string id = 1 [(gogoproto.customname) = "ID"];\n}\n\nsyntax = "proto3";\n\npackage pfsload;\noption go_package = "github.com/pachyderm/pachyderm/v2/src/internal/pfsload";\n\nimport "pfs/pfs.proto";\n\nmessage CommitSpec {\n  int64 count = 1;\n  repeated ModificationSpec modifications = 2;\n  repeated FileSourceSpec file_sources = 3;\n  ValidatorSpec validator = 4;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message ModificationSpec {\n  int64 count = 1;\n  PutFileSpec put_file = 2;\n}\n\nmessage PutFileSpec {\n  int64 count = 1;\n  string source = 2;\n}\n\nmessage PutFileTask {\n  int64 count = 1;\n  FileSourceSpec file_source = 2;\n  int64 seed = 3;\n  string auth_token = 4;\n}\n\nmessage PutFileTaskResult {\n  string file_set_id = 1;\n  bytes hash = 2;\n}\n\nmessage FileSourceSpec {\n  string name = 1;\n  RandomFileSourceSpec random = 2;\n}\n\nmessage RandomFileSourceSpec {\n  RandomDirectorySpec directory = 1;\n  repeated SizeSpec sizes = 2;\n  bool increment_path = 3;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message RandomDirectorySpec {\n  SizeSpec depth = 1;\n  int64 run = 2;\n}\n\nmessage SizeSpec {\n  int64 min_size = 1 [json_name="min"];\n  int64 max_size = 2 [json_name="max"];\n  int64 prob = 3;\n}\n\nmessage ValidatorSpec {\n  FrequencySpec frequency = 1;\n}\n\nmessage FrequencySpec {\n  int64 count = 1;\n  int64 prob = 2; \n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message State {\n  message Commit {\n    pfs_v2.Commit commit = 1;\n    bytes hash = 2;\n  }\n  repeated Commit commits = 1;\n}\n\nsyntax = "proto3";\n\n// Note: etc/proto/protoc-gen-zap/protoextensions needs a version of this file compiled with the\n// non-gogo protobuf compiler: `protoc --proto_path=. --go_out=. src/protoextensions/log.proto`\n// and then copy the generated file out of the github.com/... directory `mv\n// github.com/pachyderm/pachyderm/v2/src/protoextensions/log.pb.go\n// etc/proto/protoc-gen-zap/protoextensions/`.\n\npackage log;', metadata={'source': 'protobufs/main.proto'}), Document(page_content='option go_package = "github.com/pachyderm/pachyderm/v2/src/protoextensions";\n\nimport "google/protobuf/descriptor.proto";\n\nextend google.protobuf.FieldOptions {\n  bool mask = 50001;\n  bool half = 50002;\n}\n\nsyntax = "proto3";\n\npackage pfsserver;\noption go_package = "github.com/pachyderm/pachyderm/v2/src/server/pfs/server";\n\nimport "internal/storage/fileset/index/index.proto";\nimport "pfs/pfs.proto";', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message ShardTask {\n  repeated string inputs = 1;\n  PathRange path_range = 2;\n}\n\nmessage ShardTaskResult {\n  repeated CompactTask compact_tasks = 1;\n}\n\nmessage PathRange {\n  string lower = 1;\n  string upper = 2;\n}\n\nmessage CompactTask {\n  repeated string inputs = 1;\n  PathRange path_range = 2;\n}\n\nmessage CompactTaskResult {\n  string id = 1;\n}\n\nmessage ConcatTask {\n  repeated string inputs = 1;\n}\n\nmessage ConcatTaskResult {\n  string id = 1;\n}\n\nmessage ValidateTask {\n  string id = 1;\n  PathRange path_range = 2;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message ValidateTaskResult {\n  index.Index first = 1;\n  index.Index last = 2;\n  string error = 3;\n  int64 size_bytes = 4;\n}\n\nmessage PutFileURLTask {\n  string dst = 1;\n  string datum = 2;\n  string URL = 3;\n  repeated string paths = 4;\n  int64 start_offset = 5;\n  int64 end_offset = 7;\n}\n\nmessage PutFileURLTaskResult {\n  string id = 1;\n}\n\nmessage GetFileURLTask {\n  string URL = 1;\n  pfs_v2.File file = 2;\n  pfs_v2.PathRange path_range = 3;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message GetFileURLTaskResult {}\n\nsyntax = "proto3";\n\npackage pachyderm.worker.pipeline.transform;\noption go_package = "github.com/pachyderm/pachyderm/v2/src/server/worker/pipeline/transform";\n\nimport "gogoproto/gogo.proto";\n\nimport "pfs/pfs.proto";\nimport "pps/pps.proto";\nimport "server/worker/datum/datum.proto";\n\nmessage CreateParallelDatumsTask {\n  pps_v2.Job job = 1;\n  string salt = 2;\n  string file_set_id = 3;\n  string base_file_set_id = 4;\n  pfs_v2.PathRange path_range = 5;\n} \n\nmessage CreateParallelDatumsTaskResult {\n  string file_set_id = 1;\n  datum.Stats stats = 2;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message CreateSerialDatumsTask {\n  pps_v2.Job job = 1;\n  string salt = 2;\n  string file_set_id = 3;\n  pfs_v2.Commit base_meta_commit = 4;\n  bool no_skip = 5;\n  pfs_v2.PathRange path_range = 6;\n}\n\nmessage CreateSerialDatumsTaskResult {\n  string file_set_id = 1;\n  string output_delete_file_set_id = 2;\n  string meta_delete_file_set_id = 3;\n  datum.Stats stats = 4;\n} \n\nmessage CreateDatumSetsTask {\n  string file_set_id = 1;\n  pfs_v2.PathRange path_range = 2;\n  datum.SetSpec set_spec = 3;\n} \n\nmessage CreateDatumSetsTaskResult {\n  repeated pfs_v2.PathRange datum_sets = 1;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message DatumSetTask {\n  pps_v2.Job job = 1;\n  string file_set_id = 2;\n  pfs_v2.PathRange path_range = 3;\n  pfs_v2.Commit output_commit = 4;\n}\n\nmessage DatumSetTaskResult {\n  string output_file_set_id = 1;\n  string meta_file_set_id = 2;\n  datum.Stats stats = 3;\n}\n\n\nsyntax = "proto3";\n\npackage datum;\noption go_package = "github.com/pachyderm/pachyderm/v2/src/server/worker/datum";\n\nimport "gogoproto/gogo.proto";\n\nimport "pfs/pfs.proto";\nimport "pps/pps.proto";\nimport "server/worker/common/common.proto";\n\nenum State {\n  PROCESSED = 0;\n  FAILED = 1;\n  RECOVERED = 2;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message Meta {\n  pps_v2.Job job = 1;\n  repeated common.Input inputs = 2;\n  string hash = 3;\n  State state = 4;\n  string reason = 5;\n  pps_v2.ProcessStats stats = 6;\n  int64 index = 7;\n  string image_id = 8;\n}\n\nmessage Stats {\n  pps_v2.ProcessStats process_stats = 1;\n  int64 processed = 2;\n  int64 skipped = 3;\n  int64 total = 4;\n  int64 failed = 5;\n  int64 recovered = 6;\n  string failed_id = 7 [(gogoproto.customname) = "FailedID"];\n}\n\nmessage PFSTask {\n  pps_v2.PFSInput input = 1; \n  pfs_v2.PathRange path_range = 2;\n  int64 base_index = 3;\n  string auth_token = 4;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message PFSTaskResult {\n  string file_set_id = 1;\n}\n\nmessage CrossTask {\n  repeated string file_set_ids = 1;\n  int64 base_file_set_index = 2;\n  pfs_v2.PathRange base_file_set_path_range = 3;\n  int64 base_index = 4;\n  string auth_token = 5;\n}\n\nmessage CrossTaskResult {\n  string file_set_id = 1;\n}\n\nmessage KeyTask {\n  string file_set_id = 1;\n  pfs_v2.PathRange path_range = 2;\n  enum Type {\n    JOIN = 0;\n    GROUP = 1;\n  }\n  Type type = 3;\n  string auth_token = 4;\n}\n\nmessage KeyTaskResult {\n  string file_set_id = 1;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message KeyTaskResult {\n  string file_set_id = 1;\n}\n\nmessage MergeTask {\n  repeated string file_set_ids = 1;\n  pfs_v2.PathRange path_range = 2;\n  enum Type {\n    JOIN = 0;\n    GROUP = 1;\n  }\n  Type type = 3;\n  string auth_token = 4;\n}\n\nmessage MergeTaskResult {\n  string file_set_id = 1;\n}\n\nmessage ComposeTask {\n  repeated string file_set_ids = 1;\n  string auth_token = 2;\n}\n\nmessage ComposeTaskResult {\n  string file_set_id = 1;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message ComposeTaskResult {\n  string file_set_id = 1;\n}\n\nmessage SetSpec {\n  int64 number = 1;\n  int64 size_bytes = 2;\n}\n\nsyntax = "proto3";\n\npackage common;\noption go_package = "github.com/pachyderm/pachyderm/v2/src/server/worker/common";\n\nimport "pfs/pfs.proto";\nimport "gogoproto/gogo.proto";', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message Input {\n  reserved 2;\n\n  pfs_v2.FileInfo file_info = 1;\n  string name = 3;\n  string join_on = 4;\n  bool outer_join = 5;\n  string group_by = 6;\n  bool lazy = 7;\n  string branch = 8;\n  string git_url = 9 [(gogoproto.customname) = "GitURL"];\n  bool empty_files = 10;\n  bool s3 = 11; // If set, workers won\'t create an input directory for this input\n}\n\nsyntax = "proto3";\n\npackage pfs_v2;', metadata={'source': 'protobufs/main.proto'}), Document(page_content='option go_package = "github.com/pachyderm/pachyderm/v2/src/pfs";\n\nimport "google/protobuf/empty.proto";\nimport "google/protobuf/timestamp.proto";\nimport "google/protobuf/wrappers.proto";\nimport "google/protobuf/duration.proto";\nimport "google/protobuf/any.proto";\n\nimport "gogoproto/gogo.proto";\n\nimport "auth/auth.proto";\n\nimport "task/task.proto";\n\n////  PFS Data structures (stored in etcd)', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message Repo {\n  string name = 1;\n  string type = 2;\n  Project project = 3;\n}\n\nmessage Branch {\n  Repo repo = 1;\n  string name = 2;\n}\n\nmessage File {\n  Commit commit = 1;\n  string path = 2;\n  string datum = 3;\n}\n\n// RepoInfo is the main data structure representing a Repo in etcd', metadata={'source': 'protobufs/main.proto'}), Document(page_content="message RepoInfo {\n  Repo repo = 1;\n  google.protobuf.Timestamp created = 2;\n  int64 size_bytes_upper_bound = 3;\n  string description = 4;\n  repeated Branch branches = 5;\n\n  // Set by ListRepo and InspectRepo if Pachyderm's auth system is active, but\n  // not stored in etcd. To set a user's auth scope for a repo, use the\n  // Pachyderm Auth API (in src/client/auth/auth.proto)\n  AuthInfo auth_info = 6;\n\n  // Details are only provided when explicitly requested\n  message Details {\n    int64 size_bytes = 1;\n  }\n  Details details = 7;\n}", metadata={'source': 'protobufs/main.proto'}), Document(page_content="// AuthInfo includes the caller's access scope for a resource, and is returned\n// by services like ListRepo, InspectRepo, and ListProject, but is not persisted in the database.\n// It's used by the Pachyderm dashboard to render repo access appropriately.\n// To set a user's auth scope for a resource, use the Pachyderm Auth API (in src/auth/auth.proto)", metadata={'source': 'protobufs/main.proto'}), Document(page_content="message AuthInfo {\n  // The callers access level to the relevant resource. These are very granular\n  // permissions - for the end user it makes sense to show them the roles\n  // they have instead.\n  repeated auth_v2.Permission permissions = 1;\n\n  // The caller's roles on the relevant resource. This includes inherited\n  // roles from the cluster, project, group membership, etc.\n  repeated string roles = 2;\n}", metadata={'source': 'protobufs/main.proto'}), Document(page_content='message BranchInfo {\n  Branch branch = 1;\n  Commit head = 2;\n  repeated Branch provenance = 3;\n  repeated Branch subvenance = 4;\n  repeated Branch direct_provenance = 5;\n  Trigger trigger = 6;\n}\n\n// Trigger defines the conditions under which a head is moved, and to which\n// branch it is moved.', metadata={'source': 'protobufs/main.proto'}), Document(page_content="message Trigger {\n  // Which branch this trigger refers to\n  string branch = 1;\n  // All indicates that all conditions must be satisfied before the trigger\n  // happens, otherwise any conditions being satisfied will trigger it.\n  bool all = 2;\n  // Triggers if the cron spec has been satisfied since the last trigger and\n  // there's been a new commit.\n  string cron_spec = 3;\n  // Triggers if there's been `size` new data added since the last trigger.\n  string size = 4;\n  // Triggers if there's been `commits` new commits added since the last trigger.\n  int64 commits = 5;\n}", metadata={'source': 'protobufs/main.proto'}), Document(page_content='// These are the different places where a commit may be originated from', metadata={'source': 'protobufs/main.proto'}), Document(page_content='enum OriginKind {\n  ORIGIN_KIND_UNKNOWN = 0;\n  USER = 1;\n  AUTO = 2;\n  FSCK = 3;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message CommitOrigin {\n  OriginKind kind = 1;\n}\n// Commit is a reference to a commit (e.g. the collection of branches and the\n// collection of currently-open commits in etcd are collections of Commit\n// protos)\nmessage Commit {\n  Repo repo = 3;\n  string id = 2 [(gogoproto.customname) = "ID"];\n  // only used by the client\n  Branch branch = 1;\n}\n\n// CommitInfo is the main data structure representing a commit in etcd', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message CommitInfo {\n  reserved 9;\n  Commit commit = 1;\n  CommitOrigin origin = 2;\n  // description is a user-provided script describing this commit\n  string description = 3;\n  Commit parent_commit = 4;\n  repeated Commit child_commits = 5;\n  google.protobuf.Timestamp started = 6;\n  google.protobuf.Timestamp finishing = 7;\n  google.protobuf.Timestamp finished = 8;\n  repeated Commit direct_provenance = 13;\n  string error = 10;\n  int64 size_bytes_upper_bound = 11;', metadata={'source': 'protobufs/main.proto'}), Document(page_content='// Details are only provided when explicitly requested\n  message Details {\n    int64 size_bytes = 1;\n    google.protobuf.Duration compacting_time = 2;\n    google.protobuf.Duration validating_time = 3;\n  }\n  Details details = 12;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message CommitSet {\n  string id = 1 [(gogoproto.customname) = "ID"];\n}\n\nmessage CommitSetInfo {\n  CommitSet commit_set = 1;\n  repeated CommitInfo commits = 2;\n}\n\nenum FileType {\n  RESERVED = 0;\n  FILE = 1;\n  DIR = 2;\n}\n\nmessage FileInfo {\n  File file = 1;\n  FileType file_type = 2;\n  google.protobuf.Timestamp committed = 3;\n  int64 size_bytes = 4;\n  bytes hash = 5;\n}\n\nmessage Project {\n  string name = 1;\n}\n\nmessage ProjectInfo {\n  Project project = 1;\n  string description = 2;\n  AuthInfo auth_info = 3;\n  google.protobuf.Timestamp created_at = 4;\n}\n\n// PFS API', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message CreateRepoRequest {\n  Repo repo = 1;\n  string description = 2;\n  bool update = 3;\n}\n\nmessage InspectRepoRequest {\n  Repo repo = 1;\n}\n\nmessage ListRepoRequest {\n  // type is the type of (system) repos that should be returned\n  // an empty string requests all repos\n  string type = 1;\n  // projects filters out repos that do not belong in the list, while no projects means list all repos.\n  repeated Project projects = 2;\n}\n\nmessage DeleteRepoRequest {\n  Repo repo = 1;\n  bool force = 2;\n}\n\n// DeleteReposRequest is used to delete more than one repo at once.', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message DeleteReposRequest {\n  // All repos in each project will be deleted if the caller has\n  // permission.\n  repeated Project projects = 1;\n  bool force = 2;\n  // If all is set, then all repos in all projects will be deleted if the caller\n  // has permission.\n  bool all = 3;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message DeleteReposResponse {\n  repeated Repo repos = 1;\n}\n\n// CommitState describes the states a commit can be in.\n// The states are increasingly specific, i.e. a commit that is FINISHED also counts as STARTED.\nenum CommitState {\n  COMMIT_STATE_UNKNOWN = 0;\n  STARTED = 1; // The commit has been started, all commits satisfy this state.\n  READY = 2; // The commit has been started, and all of its provenant commits have been finished.\n  FINISHING = 3; // The commit is in the process of being finished.\n  FINISHED = 4; // The commit has been finished.\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message StartCommitRequest {\n  // parent may be empty in which case the commit that Branch points to will be used as the parent.\n  // If the branch does not exist, the commit will have no parent.\n  Commit parent = 1;\n  // description is a user-provided string describing this commit\n  string description = 2;\n  Branch branch = 3;\n}\n\nmessage FinishCommitRequest {\n  Commit commit = 1;\n  // description is a user-provided string describing this commit. Setting this\n  // will overwrite the description set in StartCommit\n  string description = 2;\n  string error = 3;\n  bool force = 4;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message InspectCommitRequest {\n  Commit commit = 1;\n  // Wait causes inspect commit to wait until the commit is in the desired state.\n  CommitState wait = 2;\n}\n\nmessage ListCommitRequest {\n  Repo repo = 1;\n  Commit from = 2;\n  Commit to = 3;\n  int64 number = 4;\n  bool reverse = 5;  // Return commits oldest to newest\n  bool all = 6; // Return commits of all kinds (without this, aliases are excluded)\n  OriginKind origin_kind = 7; // Return only commits of this kind (mutually exclusive with all)\n  google.protobuf.Timestamp started_time = 8; // Return commits started before this time\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message InspectCommitSetRequest {\n  CommitSet commit_set = 1;\n  bool wait = 2; // When true, wait until all commits in the set are finished\n}\n\nmessage ListCommitSetRequest {\n  Project project = 1;\n}\n\nmessage SquashCommitSetRequest {\n  CommitSet commit_set = 1;\n}\n\nmessage DropCommitSetRequest {\n  CommitSet commit_set = 1;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content="message SubscribeCommitRequest {\n  Repo repo = 1;\n  string branch = 2;\n  // only commits created since this commit are returned\n  Commit from = 3;\n  // Don't return commits until they're in (at least) the desired state.\n  CommitState state = 4;\n  bool all = 5; // Return commits of all kinds (without this, aliases are excluded)\n  OriginKind origin_kind = 6; // Return only commits of this kind (mutually exclusive with all)\n}\n\nmessage ClearCommitRequest {\n  Commit commit = 1;\n}", metadata={'source': 'protobufs/main.proto'}), Document(page_content="message ClearCommitRequest {\n  Commit commit = 1;\n}\n\nmessage CreateBranchRequest {\n  Commit head = 1;\n  Branch branch = 2;\n  repeated Branch provenance = 3;\n  Trigger trigger = 4;\n  bool new_commit_set = 5; // overrides the default behavior of using the same CommitSet as 'head'\n}\n\nmessage FindCommitsRequest {\n  Commit start = 1;\n  string file_path = 2;\n  uint32 limit = 3; // a limit of 0 means there is no upper bound on the limit.\n}\n\nmessage FindCommitsResponse {\n  oneof result {\n    Commit found_commit = 1;\n    Commit last_searched_commit = 2;\n  }\n  uint32 commits_searched = 3;\n}", metadata={'source': 'protobufs/main.proto'}), Document(page_content='message InspectBranchRequest {\n  Branch branch = 1;\n}\n\nmessage ListBranchRequest {\n  Repo repo = 1;\n  bool reverse = 2; // Returns branches oldest to newest\n}\n\nmessage DeleteBranchRequest {\n  Branch branch = 1;\n  bool force = 2;\n}\n\nmessage CreateProjectRequest {\n  Project project = 1;\n  string description = 2;\n  bool update = 3;\n}\n\nmessage InspectProjectRequest {\n  Project project = 1;\n}\n\nmessage ListProjectRequest {}\n\nmessage DeleteProjectRequest {\n  Project project = 1;\n  bool force = 2;\n}\n\nenum Delimiter {\n  NONE = 0;\n  JSON = 1;\n  LINE = 2;\n  SQL = 3;\n  CSV = 4;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message AddFile {\n  string path = 1;\n  string datum = 2;\n\n  message URLSource {\n    string URL = 1;\n    bool recursive = 2;\n    uint32 concurrency = 3;\n  }\n  oneof source {\n    google.protobuf.BytesValue raw = 3;\n    URLSource url = 4;\n  }\n}\n\nmessage DeleteFile {\n  string path = 1;\n  string datum = 2;\n}\n\nmessage CopyFile {\n  string dst = 1;\n  string datum = 2;\n  File src = 3;\n  bool append = 4;\n}\n\nmessage ModifyFileRequest {\n  oneof body {\n    Commit set_commit = 1;\n    AddFile add_file = 2;\n    DeleteFile delete_file = 3;\n    CopyFile copy_file = 4;\n  }\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message GetFileRequest {\n  File file = 1;\n  string URL = 2;\n  int64 offset = 3;\n  PathRange path_range = 4;\n// TODO:\n//  int64 size_bytes = 3;\n}\n\nmessage InspectFileRequest {\n  File file = 1;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message ListFileRequest {\n  reserved 2;', metadata={'source': 'protobufs/main.proto'}), Document(page_content='// File is the parent directory of the files we want to list. This sets the\n  // repo, the commit/branch, and path prefix of files we\'re interested in\n  // If the "path" field is omitted, a list of files at the top level of the repo\n  // is returned\n  File file = 1;\n  // Marker for pagination. If set, the files that come after the marker in\n  // lexicographical order will be returned. If reverse is also set, the files\n  // that come before the marker in lexicographical order will be returned.\n  File paginationMarker = 3;\n  // Number of files to return\n  int64 number = 4;', metadata={'source': 'protobufs/main.proto'}), Document(page_content='// Number of files to return\n  int64 number = 4;\n  // If true, return files in reverse order\n  bool reverse = 5;', metadata={'source': 'protobufs/main.proto'}), Document(page_content="// TODO:\n//  // History indicates how many historical versions you want returned. Its\n//  // semantics are:\n//  // 0: Return the files as they are at the commit in `file`. FileInfo.File\n//  //    will equal File in this request.\n//  // 1: Return the files as they are in the last commit they were modified in.\n//  //    (This will have the same hash as if you'd passed 0, but\n//  //    FileInfo.File.Commit will be different.\n//  // 2: Return the above and the files as they are in the next-last commit they\n//  //    were modified in.\n//  // 3: etc.\n//  //-1: Return all historical versions.", metadata={'source': 'protobufs/main.proto'}), Document(page_content='//  // 3: etc.\n//  //-1: Return all historical versions.\n//  int64 history = 3;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message WalkFileRequest {\n    File file = 1;\n    // Marker for pagination. If set, the files that come after the marker in\n    // lexicographical order will be returned. If reverse is also set, the files\n    // that come before the marker in lexicographical order will be returned.\n    File paginationMarker = 2;\n    // Number of files to return\n    int64 number = 3;\n    // If true, return files in reverse order\n    bool reverse = 4;\n}\n\nmessage GlobFileRequest {\n  Commit commit = 1;\n  string pattern = 2;\n  PathRange path_range = 3;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content="message DiffFileRequest {\n  File new_file = 1;\n  // OldFile may be left nil in which case the same path in the parent of\n  // NewFile's commit will be used.\n  File old_file = 2;\n  bool shallow = 3;\n}\n\nmessage DiffFileResponse {\n  FileInfo new_file = 1;\n  FileInfo old_file = 2;\n}\n\nmessage FsckRequest {\n  bool fix = 1;\n  oneof zombie_check {\n    Commit zombie_target = 2;\n    // run zombie data detection against all pipelines\n    bool zombie_all = 3;\n  }\n}\n\nmessage FsckResponse {\n  string fix = 1;\n  string error = 2;\n}\n\nmessage CreateFileSetResponse {\n  string file_set_id = 1;\n}", metadata={'source': 'protobufs/main.proto'}), Document(page_content='message GetFileSetRequest {\n  Commit commit = 1;\n}\n\nmessage AddFileSetRequest {\n  Commit commit = 1;\n  string file_set_id = 2;\n}\n\nmessage RenewFileSetRequest {\n  string file_set_id = 1;\n  int64 ttl_seconds = 2;\n}\n\nmessage ComposeFileSetRequest {\n  repeated string file_set_ids = 1;\n  int64 ttl_seconds = 2;\n  bool compact = 3;\n}\n\nmessage ShardFileSetRequest {\n  string file_set_id = 1;\n}\n\nmessage PathRange {\n  string lower = 1;\n  string upper = 2;\n}\n\nmessage ShardFileSetResponse {\n  repeated PathRange shards = 1;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message CheckStorageRequest {\n  bool read_chunk_data = 1;\n  bytes chunk_begin = 2;\n  bytes chunk_end = 3;\n}\n\nmessage CheckStorageResponse {\n  int64 chunk_object_count = 1;\n}\n\nmessage PutCacheRequest {\n  string key = 1;\n  google.protobuf.Any value = 2;\n  repeated string file_set_ids = 3;\n  string tag = 4;\n}\n\nmessage GetCacheRequest {\n  string key = 1;\n}\n\nmessage GetCacheResponse {\n  google.protobuf.Any value = 1;\n}\n\nmessage ClearCacheRequest {\n  string tag_prefix = 1;\n}\n\nmessage ActivateAuthRequest {}\nmessage ActivateAuthResponse {}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message ActivateAuthResponse {}\n\nmessage RunLoadTestRequest {\n  string spec = 1;\n  Branch branch = 2;\n  int64 seed = 3;\n  string state_id = 4;\n}\n\nmessage RunLoadTestResponse {\n  string spec = 1;\n  Branch branch = 2;\n  int64 seed = 3;\n  string error = 4;\n  google.protobuf.Duration duration = 5;\n  string state_id = 6;\n}\n\nmessage ObjectStorageEgress {\n  string url = 1;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message ObjectStorageEgress {\n  string url = 1;\n}\nmessage SQLDatabaseEgress {\n  message FileFormat {\n    enum Type {\n        UNKNOWN = 0;\n        CSV = 1;\n        JSON = 2;\n        PARQUET = 3;\n    }\n    Type type = 1;\n    repeated string columns = 2;\n  }\n  message Secret {\n    string name = 1;\n    string key = 2;\n  }\n\n  string url = 1;\n  FileFormat file_format = 2;\n  Secret secret = 3;\n}\nmessage EgressRequest {\n  pfs_v2.Commit commit = 1;\n  oneof target {\n    ObjectStorageEgress object_storage = 2;\n    SQLDatabaseEgress sql_database = 3;\n  }\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message EgressResponse {\n  message ObjectStorageResult {\n    int64 bytes_written = 1;\n  }\n  message SQLDatabaseResult {\n    map<string, int64> rows_written = 1;\n  }\n\n  oneof result {\n    ObjectStorageResult object_storage = 1;\n    SQLDatabaseResult sql_database = 2;\n  }\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='service API {\n  // CreateRepo creates a new repo.\n  rpc CreateRepo(CreateRepoRequest) returns (google.protobuf.Empty) {}\n  // InspectRepo returns info about a repo.\n  rpc InspectRepo(InspectRepoRequest) returns (RepoInfo) {}\n  // ListRepo returns info about all repos.\n  rpc ListRepo(ListRepoRequest) returns (stream RepoInfo) {}\n  // DeleteRepo deletes a repo.\n  rpc DeleteRepo(DeleteRepoRequest) returns (google.protobuf.Empty) {}\n  // DeleteRepos deletes more than one repo at once.  It attempts to\n  // delete every repo matching the DeleteReposRequest.  When deleting', metadata={'source': 'protobufs/main.proto'}), Document(page_content='// all repos matching a project, any repos not deletable by the\n  // caller will remain, and the project will not be empty; this is\n  // not an error.  The returned DeleteReposResponse will contain a\n  // list of all actually-deleted repos.\n  rpc DeleteRepos(DeleteReposRequest) returns (DeleteReposResponse) {}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='// StartCommit creates a new write commit from a parent commit.\n  rpc StartCommit(StartCommitRequest) returns (Commit) {}\n  // FinishCommit turns a write commit into a read commit.\n  rpc FinishCommit(FinishCommitRequest) returns (google.protobuf.Empty) {}\n  // ClearCommit removes all data from the commit.\n  rpc ClearCommit(ClearCommitRequest) returns (google.protobuf.Empty) {}\n  // InspectCommit returns the info about a commit.\n  rpc InspectCommit(InspectCommitRequest) returns (CommitInfo) {}\n  // ListCommit returns info about all commits.', metadata={'source': 'protobufs/main.proto'}), Document(page_content='// ListCommit returns info about all commits.\n  rpc ListCommit(ListCommitRequest) returns (stream CommitInfo) {}\n  // SubscribeCommit subscribes for new commits on a given branch.\n  rpc SubscribeCommit(SubscribeCommitRequest) returns (stream CommitInfo) {}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='// InspectCommitSet returns the info about a CommitSet.\n  rpc InspectCommitSet(InspectCommitSetRequest) returns (stream CommitInfo) {}\n  // ListCommitSet returns info about all CommitSets.\n  rpc ListCommitSet(ListCommitSetRequest) returns (stream CommitSetInfo) {}\n  // SquashCommitSet squashes the commits of a CommitSet into their children.\n  rpc SquashCommitSet(SquashCommitSetRequest) returns (google.protobuf.Empty) {}\n  // DropCommitSet drops the commits of a CommitSet and all data included in the commits.\n  rpc DropCommitSet(DropCommitSetRequest) returns (google.protobuf.Empty) {}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='// FindCommits searches for commits that reference a supplied file being modified in a branch.\n  rpc FindCommits(FindCommitsRequest) returns (stream FindCommitsResponse) {}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='// CreateBranch creates a new branch.\n  rpc CreateBranch(CreateBranchRequest) returns (google.protobuf.Empty) {}\n  // InspectBranch returns info about a branch.\n  rpc InspectBranch(InspectBranchRequest) returns (BranchInfo) {}\n  // ListBranch returns info about the heads of branches.\n  rpc ListBranch(ListBranchRequest) returns (stream BranchInfo) {}\n  // DeleteBranch deletes a branch; note that the commits still exist.\n  rpc DeleteBranch(DeleteBranchRequest) returns (google.protobuf.Empty) {}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='// ModifyFile performs modifications on a set of files.\n  rpc ModifyFile(stream ModifyFileRequest) returns (google.protobuf.Empty) {}\n  // GetFile returns the contents of a single file\n  rpc GetFile(GetFileRequest) returns (stream google.protobuf.BytesValue) {}\n  // GetFileTAR returns a TAR stream of the contents matched by the request\n  rpc GetFileTAR(GetFileRequest) returns (stream google.protobuf.BytesValue) {}\n  // InspectFile returns info about a file.\n  rpc InspectFile(InspectFileRequest) returns (FileInfo) {}\n  // ListFile returns info about all files.', metadata={'source': 'protobufs/main.proto'}), Document(page_content='// ListFile returns info about all files.\n  rpc ListFile(ListFileRequest) returns (stream FileInfo) {}\n  // WalkFile walks over all the files under a directory, including children of children.\n  rpc WalkFile(WalkFileRequest) returns (stream FileInfo) {}\n  // GlobFile returns info about all files.\n  rpc GlobFile(GlobFileRequest) returns (stream FileInfo) {}\n  // DiffFile returns the differences between 2 paths at 2 commits.\n  rpc DiffFile(DiffFileRequest) returns (stream DiffFileResponse) {}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='// ActivateAuth creates a role binding for all existing repos\n  rpc ActivateAuth(ActivateAuthRequest) returns (ActivateAuthResponse) {}\n\n  // DeleteAll deletes everything.\n  rpc DeleteAll(google.protobuf.Empty) returns (google.protobuf.Empty) {}\n  // Fsck does a file system consistency check for pfs.\n  rpc Fsck(FsckRequest) returns (stream FsckResponse) {}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='// FileSet API\n  // CreateFileSet creates a new file set.\n  rpc CreateFileSet(stream ModifyFileRequest) returns (CreateFileSetResponse) {}\n  // GetFileSet returns a file set with the data from a commit\n  rpc GetFileSet(GetFileSetRequest) returns (CreateFileSetResponse) {}\n  // AddFileSet associates a file set with a commit\n  rpc AddFileSet(AddFileSetRequest) returns (google.protobuf.Empty) {}\n  // RenewFileSet prevents a file set from being deleted for a set amount of time.\n  rpc RenewFileSet(RenewFileSetRequest) returns (google.protobuf.Empty) {}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='// ComposeFileSet composes a file set from a list of file sets.\n  rpc ComposeFileSet(ComposeFileSetRequest) returns (CreateFileSetResponse) {}\n  rpc ShardFileSet(ShardFileSetRequest) returns (ShardFileSetResponse) {}\n  // CheckStorage runs integrity checks for the storage layer.\n  rpc CheckStorage(CheckStorageRequest) returns (CheckStorageResponse) {}\n  rpc PutCache(PutCacheRequest) returns (google.protobuf.Empty) {}\n  rpc GetCache(GetCacheRequest) returns (GetCacheResponse) {}\n  rpc ClearCache(ClearCacheRequest) returns (google.protobuf.Empty) {}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='// RunLoadTest runs a load test.\n  rpc RunLoadTest(RunLoadTestRequest) returns (RunLoadTestResponse) {}\n  // RunLoadTestDefault runs the default load tests.\n  rpc RunLoadTestDefault(google.protobuf.Empty) returns (RunLoadTestResponse) {}\n\n  // ListTask lists PFS tasks\n  rpc ListTask(taskapi.ListTaskRequest) returns (stream taskapi.TaskInfo) {}\n\n  // Egress writes data from a commit to an external system\n  rpc Egress(EgressRequest) returns (EgressResponse) {}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='// Project API\n  // CreateProject creates a new project.\n  rpc CreateProject(CreateProjectRequest) returns (google.protobuf.Empty) {}\n  // InspectProject returns info about a project.\n  rpc InspectProject(InspectProjectRequest) returns (ProjectInfo) {}\n  // ListProject returns info about all projects.\n  rpc ListProject(ListProjectRequest) returns (stream ProjectInfo) {}\n  // DeleteProject deletes a project.\n  rpc DeleteProject(DeleteProjectRequest) returns (google.protobuf.Empty) {}\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='syntax = "proto3";', metadata={'source': 'protobufs/main.proto'}), Document(page_content='import "google/protobuf/empty.proto";\n\npackage versionpb_v2;', metadata={'source': 'protobufs/main.proto'}), Document(page_content='option go_package = "github.com/pachyderm/pachyderm/v2/src/version/versionpb";', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message Version {\n  uint32 major = 1;\n  uint32 minor = 2;\n  uint32 micro = 3;\n  string additional = 4;\n  string git_commit = 5;\n  string git_tree_modified = 6;\n  string build_date = 7;\n  string go_version = 8;\n  string platform = 9;\n}\n\nservice API {\n  rpc GetVersion(google.protobuf.Empty) returns (Version) {}\n}\n\nsyntax = "proto3";\n\npackage taskapi;\noption go_package = "github.com/pachyderm/pachyderm/v2/src/task";\n\nimport "gogoproto/gogo.proto";\n\nenum State {\n  UNKNOWN = 0;\n  RUNNING = 1;\n  SUCCESS = 2;\n  FAILURE = 3;\n  CLAIMED = 4; // not a real state used by task logic\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message Group {\n  string namespace = 1;\n  string group = 2;\n}\n\nmessage TaskInfo {\n  string id = 1 [(gogoproto.customname) = "ID"];\n  Group group = 2;\n  State state = 3;\n  string reason = 4;\n  string input_type = 5;\n  string input_data = 6;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message ListTaskRequest {\n  Group group = 1;\n}\n\n\nsyntax = "proto3";\n\npackage pps_v2;\noption go_package = "github.com/pachyderm/pachyderm/v2/src/pps";\n\nimport "google/protobuf/empty.proto";\nimport "google/protobuf/timestamp.proto";\nimport "google/protobuf/duration.proto";\nimport "google/protobuf/wrappers.proto";\n\nimport "gogoproto/gogo.proto";\n\nimport "pfs/pfs.proto";\n\nimport "task/task.proto";', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message SecretMount {\n  // Name must be the name of the secret in kubernetes.\n  string name = 1;\n  // Key of the secret to load into env_var, this field only has meaning if EnvVar != "".\n  string key = 2;\n  string mount_path = 3;\n  string env_var = 4;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message Transform {\n  string image = 1;\n  repeated string cmd = 2;\n  repeated string err_cmd = 3;\n  map<string, string> env = 4;\n  repeated SecretMount secrets = 5;\n  repeated string image_pull_secrets = 6;\n  repeated string stdin = 7;\n  repeated string err_stdin = 8;\n  repeated int64 accept_return_code = 9;\n  bool debug = 10;\n  string user = 11;\n  string working_dir = 12;\n  string dockerfile = 13;\n  bool memory_volume = 14;\n  bool datum_batching = 15;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message TFJob {\n  // tf_job  is a serialized Kubeflow TFJob spec. Pachyderm sends this directly\n  // to a kubernetes cluster on which kubeflow has been installed, instead of\n  // creating a pipeline ReplicationController as it normally would.\n  string tf_job = 1 [(gogoproto.customname) = "TFJob"];\n}\n\nmessage Egress {\n  string URL = 1;\n  oneof target {\n    pfs_v2.ObjectStorageEgress object_storage = 2;\n    pfs_v2.SQLDatabaseEgress sql_database = 3;\n  }\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message Job {\n  Pipeline pipeline = 1;\n  string id = 2 [(gogoproto.customname) = "ID"];\n}\n\nenum JobState {\n  JOB_STATE_UNKNOWN = 0;\n  JOB_CREATED = 1;\n  JOB_STARTING = 2;\n  JOB_RUNNING = 3;\n  JOB_FAILURE = 4;\n  JOB_SUCCESS = 5;\n  JOB_KILLED = 6;\n  JOB_EGRESSING = 7;\n  JOB_FINISHING = 8;\n  JOB_UNRUNNABLE = 9;\n}\n\nmessage Metadata {\n  map<string, string> annotations = 1;\n  map<string, string> labels = 2;\n}\n\nmessage Service {\n  int32 internal_port = 1;\n  int32 external_port = 2;\n  string ip = 3 [(gogoproto.customname) = "IP"];\n  string type = 4;\n}\n\nmessage Spout {\n  Service service = 1;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message PFSInput {\n  string project = 14;\n  string name = 1;\n  string repo = 2;\n  string repo_type = 13;\n  string branch = 3;\n  string commit = 4;\n  string glob = 5;\n  string join_on = 6;\n  bool outer_join = 7;\n  string group_by = 8;\n  bool lazy = 9;\n  // EmptyFiles, if true, will cause files from this PFS input to be\n  // presented as empty files. This is useful in shuffle pipelines where you\n  // want to read the names of files and reorganize them using symlinks.\n  bool empty_files = 10;\n  // S3, if true, will cause the worker to NOT download or link files from this', metadata={'source': 'protobufs/main.proto'}), Document(page_content="// input into the /pfs_v2 directory. Instead, an instance of our S3 gateway\n  // service will run on each of the sidecars, and data can be retrieved from\n  // this input by querying\n  // http://<pipeline>-s3.<namespace>/<job id>.<input>/my/file\n  bool s3 = 11;\n  // Trigger defines when this input is processed by the pipeline, if it's nil\n  // the input is processed anytime something is committed to the input branch.\n  pfs_v2.Trigger trigger = 12;\n}", metadata={'source': 'protobufs/main.proto'}), Document(page_content='message CronInput {\n  string name = 1;\n  string project = 7;\n  string repo = 2;\n  string commit = 3;\n  string spec = 4;\n  // Overwrite, if true, will expose a single datum that gets overwritten each\n  // tick. If false, it will create a new datum for each tick.\n  bool overwrite = 5;\n  google.protobuf.Timestamp start = 6;\n}\n\n\nmessage Input {\n  PFSInput pfs = 1;\n  repeated Input join = 2;\n  repeated Input group = 3;\n  repeated Input cross = 4;\n  repeated Input union = 5;\n  CronInput cron = 6;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content="message JobInput {\n  string name = 1;\n  pfs_v2.Commit commit = 2;\n  string glob = 3;\n  bool lazy = 4;\n}\n\nmessage ParallelismSpec {\n  // Starts the pipeline/job with a 'constant' workers, unless 'constant' is\n  // zero. If 'constant' is zero (which is the zero value of ParallelismSpec),\n  // then Pachyderm will choose the number of workers that is started,\n  // (currently it chooses the number of workers in the cluster)\n  uint64 constant = 1;\n}\n\nmessage InputFile {\n  // This file's absolute path within its pfs repo.\n  string path = 1;\n\n  // This file's hash\n  bytes hash = 2;\n}", metadata={'source': 'protobufs/main.proto'}), Document(page_content='message Datum {\n  // ID is the hash computed from all the files\n  Job job = 1;\n  string id = 2 [(gogoproto.customname) = "ID"];\n}\n\nenum DatumState {\n  UNKNOWN = 0; // or not part of a job\n  FAILED = 1;\n  SUCCESS = 2;\n  SKIPPED = 3;\n  STARTING = 4;\n  RECOVERED = 5;\n}\n\nmessage DatumInfo {\n  Datum datum = 1;\n  DatumState state = 2;\n  ProcessStats stats = 3;\n  pfs_v2.File pfs_state = 4;\n  repeated pfs_v2.FileInfo data = 5;\n  string image_id = 6;\n}\n\nmessage Aggregate {\n  int64 count = 1;\n  double mean = 2;\n  double stddev = 3;\n  double fifth_percentile = 4;\n  double ninety_fifth_percentile = 5;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message ProcessStats {\n  google.protobuf.Duration download_time = 1;\n  google.protobuf.Duration process_time = 2;\n  google.protobuf.Duration upload_time = 3;\n  int64 download_bytes = 4;\n  int64 upload_bytes = 5;\n}\n\nmessage AggregateProcessStats {\n  Aggregate download_time = 1;\n  Aggregate process_time = 2;\n  Aggregate upload_time = 3;\n  Aggregate download_bytes = 4;\n  Aggregate upload_bytes = 5;\n}\n\nmessage WorkerStatus {\n  string worker_id = 1 [(gogoproto.customname) = "WorkerID"];\n  string job_id = 2 [(gogoproto.customname) = "JobID"];\n  DatumStatus datum_status = 3;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message DatumStatus {\n  // Started is the time processing on the current datum began.\n  google.protobuf.Timestamp started = 1;\n  repeated InputFile data = 2;\n}\n\n// ResourceSpec describes the amount of resources that pipeline pods should\n// request from kubernetes, for scheduling.', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message ResourceSpec {\n  // The number of CPUs each worker needs (partial values are allowed, and\n  // encouraged)\n  float cpu = 1;\n\n  // The amount of memory each worker needs (in bytes, with allowed\n  // SI suffixes (M, K, G, Mi, Ki, Gi, etc).\n  string memory = 2;\n\n  // The spec for GPU resources.\n  GPUSpec gpu = 3;\n\n  // The amount of ephemeral storage each worker needs (in bytes, with allowed\n  // SI suffixes (M, K, G, Mi, Ki, Gi, etc).\n  string disk = 4;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content="message GPUSpec {\n  // The type of GPU (nvidia.com/gpu or amd.com/gpu for example).\n  string type = 1;\n  // The number of GPUs to request.\n  int64 number = 2;\n}\n\nmessage JobSetInfo {\n  JobSet job_set = 1;\n  repeated JobInfo jobs = 2;\n}\n\n// JobInfo is the data stored in the database regarding a given job.  The\n// 'details' field contains more information about the job which is expensive to\n// fetch, requiring querying workers or loading the pipeline spec from object\n// storage.", metadata={'source': 'protobufs/main.proto'}), Document(page_content='message JobInfo {\n  Job job = 1;\n  uint64 pipeline_version = 2;\n  pfs_v2.Commit output_commit = 3;\n  // Job restart count (e.g. due to datum failure)\n  uint64 restart = 4;\n\n  // Counts of how many times we processed or skipped a datum\n  int64 data_processed = 5;\n  int64 data_skipped = 6;\n  int64 data_total = 7;\n  int64 data_failed = 8;\n  int64 data_recovered = 9;\n\n  // Download/process/upload time and download/upload bytes\n  ProcessStats stats = 10;', metadata={'source': 'protobufs/main.proto'}), Document(page_content='JobState state = 11;\n  string reason = 12; // reason explains why the job is in the current state\n  google.protobuf.Timestamp created = 13;\n  google.protobuf.Timestamp started = 14;\n  google.protobuf.Timestamp finished = 15;', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message Details {\n    Transform transform = 1;\n    ParallelismSpec parallelism_spec = 2;\n    Egress egress = 3;\n    Service service = 4;\n    Spout spout = 5;\n    repeated WorkerStatus worker_status = 6;\n    ResourceSpec resource_requests = 7;\n    ResourceSpec resource_limits = 8;\n    ResourceSpec sidecar_resource_limits = 9;\n    Input input = 10;\n    string salt = 11;\n    DatumSetSpec datum_set_spec = 12;\n    google.protobuf.Duration datum_timeout = 13;\n    google.protobuf.Duration job_timeout = 14;\n    int64 datum_tries = 15;\n    SchedulingSpec scheduling_spec = 16;', metadata={'source': 'protobufs/main.proto'}), Document(page_content='SchedulingSpec scheduling_spec = 16;\n    string pod_spec = 17;\n    string pod_patch = 18;\n    ResourceSpec sidecar_resource_requests = 19;\n  }\n  Details details = 16;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='enum WorkerState {\n  WORKER_STATE_UNKNOWN = 0;\n  POD_RUNNING = 1;\n  POD_SUCCESS = 2;\n  POD_FAILED = 3;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message Worker {\n  string name = 1;\n  WorkerState state = 2;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message Pipeline {\n  pfs_v2.Project project = 2;\n  string name = 1;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='enum PipelineState {\n  PIPELINE_STATE_UNKNOWN = 0;\n  // There is a PipelineInfo + spec commit, but no RC\n  // This happens when a pipeline has been created but not yet picked up by a\n  // PPS server.\n  PIPELINE_STARTING = 1;\n  // A pipeline has a spec commit and a service + RC\n  // This is the normal state of a pipeline.\n  PIPELINE_RUNNING = 2;\n  // Equivalent to STARTING (there is a PipelineInfo + commit, but no RC)\n  // After some error caused runPipeline to exit, but before the pipeline is\n  // re-run. This is when the exponential backoff is in effect.\n  PIPELINE_RESTARTING = 3;', metadata={'source': 'protobufs/main.proto'}), Document(page_content="PIPELINE_RESTARTING = 3;\n  // The pipeline has encountered unrecoverable errors and is no longer being\n  // retried. It won't leave this state until the pipeline is updated.\n  PIPELINE_FAILURE = 4;\n  // The pipeline has been explicitly paused by the user (the pipeline spec's\n  // Stopped field should be true if the pipeline is in this state)\n  PIPELINE_PAUSED = 5;\n  // The pipeline is fully functional, but there are no commits to process.\n  PIPELINE_STANDBY = 6;\n  // The pipeline's workers are crashing, or failing to come up, this may", metadata={'source': 'protobufs/main.proto'}), Document(page_content='// resolve itself, the pipeline may make progress while in this state if the\n  // problem is only being experienced by some workers.\n  PIPELINE_CRASHING = 7;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='// Toleration is a Kubernetes toleration.', metadata={'source': 'protobufs/main.proto'}), Document(page_content="message Toleration {\n  // key is the taint key that the toleration applies to.  Empty means match all taint keys.\n  string key = 1;\n  // operator represents a key's relationship to the value.\n  TolerationOperator operator = 2;\n  // value is the taint value the toleration matches to.\n  string value = 3;\n  // effect indicates the taint effect to match.  Empty means match all taint effects.\n  TaintEffect effect = 4;\n  // toleration_seconds represents the period of time the toleration (which must be of effect", metadata={'source': 'protobufs/main.proto'}), Document(page_content='// NoExecute, otherwise this field is ignored) tolerates the taint.  If not set, tolerate the\n  // taint forever.\n  google.protobuf.Int64Value toleration_seconds = 5;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content="// TolerationOperator relates a Toleration's key to its value.", metadata={'source': 'protobufs/main.proto'}), Document(page_content='enum TolerationOperator {\n  EMPTY = 0; // K8s doesn\'t have this, but it\'s possible to represent something similar.\n  EXISTS = 1; // "Exists"\n  EQUAL = 2; // "Equal"\n}\n\n// TaintEffect is an effect that can be matched by a toleration.', metadata={'source': 'protobufs/main.proto'}), Document(page_content='enum TaintEffect {\n  ALL_EFFECTS = 0; // Empty matches all effects.\n  NO_SCHEDULE = 1; // "NoSchedule"\n  PREFER_NO_SCHEDULE = 2; // "PreferNoSchedule"\n  NO_EXECUTE = 3; // "NoExecute"\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content="// PipelineInfo is proto for each pipeline that Pachd stores in the\n// database. It tracks the state of the pipeline, and points to its metadata in\n// PFS (and, by pointing to a PFS commit, de facto tracks the pipeline's\n// version).  Any information about the pipeline _not_ stored in the database is\n// in the Details object, which requires fetching the spec from PFS or other\n// potentially expensive operations.", metadata={'source': 'protobufs/main.proto'}), Document(page_content='message PipelineInfo {\n  Pipeline pipeline = 1;\n  uint64 version = 2;\n  pfs_v2.Commit spec_commit = 3; // The first spec commit for this version of the pipeline\n  bool stopped = 4;\n\n  // state indicates the current state of the pipeline\n  PipelineState state = 5;\n  // reason includes any error messages associated with a failed pipeline\n  string reason = 6;\n\n  reserved 7; // map<int32, int32> job_counts;\n  // last_job_state indicates the state of the most recently created job\n  JobState last_job_state = 8;', metadata={'source': 'protobufs/main.proto'}), Document(page_content='// parallelism tracks the literal number of workers that this pipeline should\n  // run.\n  uint64 parallelism = 9;\n\n  // The pipeline type is stored here so that we can internally know the type of\n  // the pipeline without loading the spec from PFS.\n  enum PipelineType {\n    PIPELINT_TYPE_UNKNOWN = 0;\n    PIPELINE_TYPE_TRANSFORM = 1;\n    PIPELINE_TYPE_SPOUT = 2;\n    PIPELINE_TYPE_SERVICE = 3;\n  }\n  PipelineType type = 10;\n\n  string auth_token = 11;', metadata={'source': 'protobufs/main.proto'}), Document(page_content='string auth_token = 11;\n\n  message Details {\n    Transform transform = 1;\n    // tf_job encodes a Kubeflow TFJob spec. Pachyderm uses this to create TFJobs\n    // when running in a kubernetes cluster on which kubeflow has been installed.\n    // Exactly one of \'tf_job\' and \'transform\' should be set\n    TFJob tf_job = 2 [(gogoproto.customname) = "TFJob"];\n    ParallelismSpec parallelism_spec = 3;\n    Egress egress = 4;\n    google.protobuf.Timestamp created_at = 5;\n\n    string recent_error = 6;\n\n    int64 workers_requested = 7;\n    int64 workers_available = 8;', metadata={'source': 'protobufs/main.proto'}), Document(page_content='string output_branch = 9;\n    ResourceSpec resource_requests = 10;\n    ResourceSpec resource_limits = 11;\n    ResourceSpec sidecar_resource_limits = 12;\n    Input input = 13;\n    string description = 14;\n    string salt = 16;', metadata={'source': 'protobufs/main.proto'}), Document(page_content='string reason = 17;\n    Service service = 19;\n    Spout spout = 20;\n    DatumSetSpec datum_set_spec = 21;\n    google.protobuf.Duration datum_timeout = 22;\n    google.protobuf.Duration job_timeout = 23;\n    int64 datum_tries = 24;\n    SchedulingSpec scheduling_spec = 25;\n    string pod_spec = 26;\n    string pod_patch = 27;\n    bool s3_out = 28;\n    Metadata metadata = 29;\n    string reprocess_spec = 30;\n    int64 unclaimed_tasks = 31;\n    string worker_rc = 32;\n    bool autoscaling = 33;\n    repeated Toleration tolerations = 34;\n    ResourceSpec sidecar_resource_requests = 35;\n  }', metadata={'source': 'protobufs/main.proto'}), Document(page_content='ResourceSpec sidecar_resource_requests = 35;\n  }\n  Details details = 12;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message PipelineInfos {\n  repeated PipelineInfo pipeline_info = 1;\n}\n\nmessage JobSet {\n  string id = 1 [(gogoproto.customname) = "ID"];\n}\n\nmessage InspectJobSetRequest {\n  JobSet job_set = 1;\n  bool wait = 2; // When true, wait until all jobs in the set are finished\n  bool details = 3;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content="message ListJobSetRequest {\n  bool details = 1;\n  // A list of projects to filter jobs on, nil means don't filter.\n  repeated pfs_v2.Project projects = 2;\n  // we return job sets created before or after this time based on the reverse flag\n  google.protobuf.Timestamp paginationMarker = 3;\n  // number of results to return\n  int64 number = 4;\n  // if true, return results in reverse order\n  bool reverse = 5;\n}", metadata={'source': 'protobufs/main.proto'}), Document(page_content='message InspectJobRequest {\n  // Callers should set either Job or OutputCommit, not both.\n  Job job = 1;\n  bool wait = 2; // wait until state is either FAILURE or SUCCESS\n  bool details = 3;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content="message ListJobRequest {\n  // A list of projects to filter jobs on, nil means don't filter.\n  repeated pfs_v2.Project projects = 7;\n  Pipeline pipeline = 1;                // nil means all pipelines\n  repeated pfs_v2.Commit input_commit = 2; // nil means all inputs\n\n  // History indicates return jobs from historical versions of pipelines\n  // semantics are:\n  // 0: Return jobs from the current version of the pipeline or pipelines.\n  // 1: Return the above and jobs from the next most recent version\n  // 2: etc.\n  //-1: Return jobs from all historical versions.\n  int64 history = 4;", metadata={'source': 'protobufs/main.proto'}), Document(page_content='// Details indicates whether the result should include all pipeline details in\n  // each JobInfo, or limited information including name and status, but\n  // excluding information in the pipeline spec. Leaving this "false" can make\n  // the call significantly faster in clusters with a large number of pipelines\n  // and jobs.\n  // Note that if \'input_commit\' is set, this field is coerced to "true"\n  bool details = 5;\n\n  // A jq program string for additional result filtering\n  string jqFilter = 6;\n\n  // timestamp that is pagination marker\n  google.protobuf.Timestamp paginationMarker = 8;', metadata={'source': 'protobufs/main.proto'}), Document(page_content='// number of results to return\n  int64 number = 9;\n\n  // flag to indicated if results should be returned in reverse order\n  bool reverse = 10;\n}\n\n// Streams open jobs until canceled', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message SubscribeJobRequest {\n  Pipeline pipeline = 1;\n  bool details = 2; // Same as ListJobRequest.Details\n}\n\nmessage DeleteJobRequest {\n  Job job = 1;\n}\n\nmessage StopJobRequest {\n  Job job = 1;\n  string reason = 3;\n}\n\nmessage UpdateJobStateRequest {\n  Job job = 1;\n  JobState state = 2;\n  string reason = 3;\n  uint64 restart = 5;\n  int64 data_processed = 6;\n  int64 data_skipped = 7;\n  int64 data_failed = 8;\n  int64 data_recovered = 9;\n  int64 data_total = 10;\n  ProcessStats stats = 11;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content="message GetLogsRequest {\n  // The pipeline from which we want to get logs (required if the job in 'job'\n  // was created as part of a pipeline. To get logs from a non-orphan job\n  // without the pipeline that created it, you need to use ElasticSearch).\n  Pipeline pipeline = 1;\n\n  // The job from which we want to get logs.\n  Job job = 2;", metadata={'source': 'protobufs/main.proto'}), Document(page_content='// Names of input files from which we want processing logs. This may contain\n  // multiple files, to query pipelines that contain multiple inputs. Each\n  // filter may be an absolute path of a file within a pps repo, or it may be\n  // a hash for that file (to search for files at specific versions)\n  repeated string data_filters = 3;\n\n  Datum datum = 4;\n\n  // If true get logs from the master process\n  bool master = 5;\n\n  // Continue to follow new logs as they become available.\n  bool follow = 6;', metadata={'source': 'protobufs/main.proto'}), Document(page_content='// If nonzero, the number of lines from the end of the logs to return.  Note:\n  // tail applies per container, so you will get tail * <number of pods> total\n  // lines back.\n  int64 tail = 7;\n\n  // UseLokiBackend causes the logs request to go through the loki backend\n  // rather than through kubernetes. This behavior can also be achieved by\n  // setting the LOKI_LOGGING feature flag.\n  bool use_loki_backend = 8;\n\n  // Since specifies how far in the past to return logs from. It defaults to 24 hours.\n  google.protobuf.Duration since = 9;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='// LogMessage is a log line from a PPS worker, annotated with metadata\n// indicating when and why the line was logged.', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message LogMessage {\n  // The job and pipeline for which a PFS file is being processed (if the job\n  // is an orphan job, pipeline name and ID will be unset)\n  string project_name = 10;\n  string pipeline_name = 1;\n  string job_id = 2 [(gogoproto.customname) = "JobID"];\n  string worker_id = 3 [(gogoproto.customname) = "WorkerID"];\n  string datum_id = 4 [(gogoproto.customname) = "DatumID"];\n  bool master = 5;\n\n  // The PFS files being processed (one per pipeline/job input)\n  repeated InputFile data = 6;\n\n  // User is true if log message comes from the users code.\n  bool user = 7;', metadata={'source': 'protobufs/main.proto'}), Document(page_content='// The message logged, and the time at which it was logged\n  google.protobuf.Timestamp ts = 8;\n  string message = 9;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message RestartDatumRequest {\n  Job job = 1;\n  repeated string data_filters = 2;\n}\n\nmessage InspectDatumRequest {\n  Datum datum = 1;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message ListDatumRequest {\n  // Filter restricts returned DatumInfo messages to those which match\n  // all of the filtered attributes.\n  message Filter {\n    repeated DatumState state = 1;  // Must match one of the given states.\n  }\n  // Job and Input are two different ways to specify the datums you want.\n  // Only one can be set.\n  // Job is the job to list datums from.\n  Job job = 1;\n  // Input is the input to list datums from.\n  // The datums listed are the ones that would be run if a pipeline was created\n  // with the provided input.\n  Input input = 2;\n  Filter filter = 3;', metadata={'source': 'protobufs/main.proto'}), Document(page_content='Input input = 2;\n  Filter filter = 3;\n  //datum id to start from. we do not include this datum in the response\n  string paginationMarker = 4;\n  // Number of datums to return\n  int64 number = 5;\n  // If true, return datums in reverse order\n  bool reverse = 6;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='// DatumSetSpec specifies how a pipeline should split its datums into datum sets.', metadata={'source': 'protobufs/main.proto'}), Document(page_content="message DatumSetSpec {\n  // number, if nonzero, specifies that each datum set should contain `number`\n  // datums. Datum sets may contain fewer if the total number of datums don't\n  // divide evenly.\n  int64 number = 1;\n  // size_bytes, if nonzero, specifies a target size for each datum set.\n  // Datum sets may be larger or smaller than size_bytes, but will usually be\n  // pretty close to size_bytes in size.\n  int64 size_bytes = 2;", metadata={'source': 'protobufs/main.proto'}), Document(page_content="// per_worker, if nonzero, specifies how many datum sets should be created\n  // for each worker. It can't be set with number or size_bytes.\n  int64 per_worker = 3;\n}", metadata={'source': 'protobufs/main.proto'}), Document(page_content='message SchedulingSpec {\n  map<string, string> node_selector = 1;\n  string priority_class_name = 2;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message CreatePipelineRequest {\n  Pipeline pipeline = 1;\n  // tf_job encodes a Kubeflow TFJob spec. Pachyderm uses this to create TFJobs\n  // when running in a kubernetes cluster on which kubeflow has been installed.\n  // Exactly one of \'tf_job\' and \'transform\' should be set\n  TFJob tf_job = 2 [(gogoproto.customname) = "TFJob"];\n  Transform transform = 3;\n  ParallelismSpec parallelism_spec = 4;\n  Egress egress = 5;\n  bool update = 6;\n  string output_branch = 7;\n  // s3_out, if set, requires a pipeline\'s user to write to its output repo', metadata={'source': 'protobufs/main.proto'}), Document(page_content="// via Pachyderm's s3 gateway (if set, workers will serve Pachyderm's s3\n  // gateway API at http://<pipeline>-s3.<namespace>/<job id>.out/my/file).\n  // In this mode /pfs_v2/out won't be walked or uploaded, and the s3 gateway\n  // service in the workers will allow writes to the job's output commit\n  bool s3_out = 8;\n  ResourceSpec resource_requests = 9;\n  ResourceSpec resource_limits = 10;\n  ResourceSpec sidecar_resource_limits = 11;\n  Input input = 12;\n  string description = 13;\n  // Reprocess forces the pipeline to reprocess all datums.\n  // It only has meaning if Update is true", metadata={'source': 'protobufs/main.proto'}), Document(page_content="// It only has meaning if Update is true\n  bool reprocess = 15;\n  Service service = 17;\n  Spout spout = 18;\n  DatumSetSpec datum_set_spec = 19;\n  google.protobuf.Duration datum_timeout = 20;\n  google.protobuf.Duration job_timeout = 21;\n  string salt = 22;\n  int64 datum_tries = 23;\n  SchedulingSpec scheduling_spec = 24;\n  string pod_spec = 25; // deprecated, use pod_patch below\n  string pod_patch = 26; // a json patch will be applied to the pipeline's pod_spec before it's created;\n  pfs_v2.Commit spec_commit = 27;\n  Metadata metadata = 28;\n  string reprocess_spec = 29;", metadata={'source': 'protobufs/main.proto'}), Document(page_content='Metadata metadata = 28;\n  string reprocess_spec = 29;\n  bool autoscaling = 30;\n  repeated Toleration tolerations = 34;\n  ResourceSpec sidecar_resource_requests = 35;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message InspectPipelineRequest {\n  Pipeline pipeline = 1;\n  // When true, return PipelineInfos with the details field, which requires\n  // loading the pipeline spec from PFS.\n  bool details = 2;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message ListPipelineRequest {\n  // If non-nil, only return info about a single pipeline, this is redundant\n  // with InspectPipeline unless history is non-zero.\n  Pipeline pipeline = 1;\n  // History indicates how many historical versions you want returned. Its\n  // semantics are:\n  // 0: Return the current version of the pipeline or pipelines.\n  // 1: Return the above and the next most recent version\n  // 2: etc.\n  //-1: Return all historical versions.\n  int64 history = 2;', metadata={'source': 'protobufs/main.proto'}), Document(page_content='// When true, return PipelineInfos with the details field, which requires\n  // loading the pipeline spec from PFS.\n  bool details = 3;\n\n  // A jq program string for additional result filtering\n  string jqFilter = 4;\n\n  // If non-nil, will return all the pipeline infos at this commit set\n  pfs_v2.CommitSet commit_set = 5;\n\n  // Projects to filter on. Empty list means no filter, so return all pipelines.\n  repeated pfs_v2.Project projects = 6;\n}\n\n// Delete a pipeline.  If the deprecated all member is true, then delete all\n// pipelines in the default project.', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message DeletePipelineRequest {\n  Pipeline pipeline = 1;\n  bool all = 2 [deprecated = true];\n  bool force = 3;\n  bool keep_repo = 4;\n}\n\n// Delete more than one pipeline.\nmessage DeletePipelinesRequest {\n  // All pipelines in each project will be deleted if the caller has\n  // permission.\n  repeated pfs_v2.Project projects = 1;\n  bool force = 2;\n  bool keep_repo = 3;\n  // If set, all pipelines in all projects will be deleted if the caller has\n  // permission.\n  bool all = 4;\n}\n\nmessage DeletePipelinesResponse {\n  repeated Pipeline pipelines = 1;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message StartPipelineRequest {\n  Pipeline pipeline = 1;\n}\n\nmessage StopPipelineRequest {\n  Pipeline pipeline = 1;\n}\n\nmessage RunPipelineRequest {\n  Pipeline pipeline = 1;\n  repeated pfs_v2.Commit provenance = 2;\n  string job_id = 3 [(gogoproto.customname) = "JobID"];\n}\n\nmessage RunCronRequest {\n  Pipeline pipeline = 1;\n}\n\nmessage CreateSecretRequest {\n  bytes file = 1;\n}\n\nmessage DeleteSecretRequest {\n  Secret secret = 1;\n}\n\nmessage InspectSecretRequest {\n  Secret secret = 1;\n}\n\nmessage Secret {\n  string name = 1;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message Secret {\n  string name = 1;\n}\n\nmessage SecretInfo {\n  Secret secret = 1;\n  string type = 2;\n  google.protobuf.Timestamp creation_timestamp = 3;\n}\n\nmessage SecretInfos {\n  repeated SecretInfo secret_info = 1;\n}\n\nmessage ActivateAuthRequest {}\nmessage ActivateAuthResponse {}\n\nmessage RunLoadTestRequest {\n  string dag_spec = 1;\n  string load_spec = 2;\n  int64 seed = 3;\n  int64 parallelism = 4;\n  string pod_patch = 5;\n  string state_id = 6;\n}\n\nmessage RunLoadTestResponse {\n  string error = 1;\n  string state_id = 2;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message RenderTemplateRequest {\n  string template = 1;\n  map<string, string> args = 2;\n}\n\nmessage RenderTemplateResponse {\n  string json = 1;\n  repeated CreatePipelineRequest specs = 2;\n}\n\nmessage LokiRequest {\n  google.protobuf.Duration since = 1;\n  string query = 2;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message LokiLogMessage {\n  string message = 1;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='service API {\n  rpc InspectJob(InspectJobRequest) returns (JobInfo) {}\n  rpc InspectJobSet(InspectJobSetRequest) returns (stream JobInfo) {}\n  // ListJob returns information about current and past Pachyderm jobs.\n  rpc ListJob(ListJobRequest) returns (stream JobInfo) {}\n  rpc ListJobSet(ListJobSetRequest) returns (stream JobSetInfo) {}\n  rpc SubscribeJob(SubscribeJobRequest) returns (stream JobInfo) {}\n  rpc DeleteJob(DeleteJobRequest) returns (google.protobuf.Empty) {}\n  rpc StopJob(StopJobRequest) returns (google.protobuf.Empty) {}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='rpc InspectDatum(InspectDatumRequest) returns (DatumInfo) {}\n  // ListDatum returns information about each datum fed to a Pachyderm job\n  rpc ListDatum(ListDatumRequest) returns (stream DatumInfo) {}\n  rpc RestartDatum(RestartDatumRequest) returns (google.protobuf.Empty) {}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='rpc CreatePipeline(CreatePipelineRequest) returns (google.protobuf.Empty) {}\n  rpc InspectPipeline(InspectPipelineRequest) returns (PipelineInfo) {}\n  rpc ListPipeline(ListPipelineRequest) returns (stream PipelineInfo) {}\n  rpc DeletePipeline(DeletePipelineRequest) returns (google.protobuf.Empty) {}\n  rpc DeletePipelines(DeletePipelinesRequest) returns (DeletePipelinesResponse) {}\n  rpc StartPipeline(StartPipelineRequest) returns (google.protobuf.Empty) {}\n  rpc StopPipeline(StopPipelineRequest) returns (google.protobuf.Empty) {}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='rpc RunPipeline(RunPipelineRequest) returns (google.protobuf.Empty) {}\n  rpc RunCron(RunCronRequest) returns (google.protobuf.Empty) {}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='rpc CreateSecret(CreateSecretRequest) returns (google.protobuf.Empty) {}\n  rpc DeleteSecret(DeleteSecretRequest) returns (google.protobuf.Empty) {}\n  rpc ListSecret(google.protobuf.Empty) returns (SecretInfos) {}\n  rpc InspectSecret(InspectSecretRequest) returns (SecretInfo) {}\n\n  // DeleteAll deletes everything\n  rpc DeleteAll(google.protobuf.Empty) returns (google.protobuf.Empty) {}\n  rpc GetLogs(GetLogsRequest) returns (stream LogMessage) {}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='// An internal call that causes PPS to put itself into an auth-enabled state\n  // (all pipeline have tokens, correct permissions, etcd)\n  rpc ActivateAuth(ActivateAuthRequest) returns (ActivateAuthResponse) {}\n\n  // An internal call used to move a job from one state to another\n  rpc UpdateJobState(UpdateJobStateRequest) returns(google.protobuf.Empty) {}\n\n  // RunLoadTest runs a load test.\n  rpc RunLoadTest(RunLoadTestRequest) returns (RunLoadTestResponse) {}\n  // RunLoadTestDefault runs the default load test.\n  rpc RunLoadTestDefault(google.protobuf.Empty) returns (RunLoadTestResponse) {}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='// RenderTemplate renders the provided template and arguments into a list of Pipeline specicifications\n  rpc RenderTemplate(RenderTemplateRequest) returns (RenderTemplateResponse) {}\n\n  // ListTask lists PPS tasks\n  rpc ListTask(taskapi.ListTaskRequest) returns (stream taskapi.TaskInfo) {}\n\n  // GetKubeEvents returns a stream of kubernetes events\n  rpc GetKubeEvents(LokiRequest) returns (stream LokiLogMessage) {}\n\n  // QueryLoki returns a stream of loki log messages given a query string\n  rpc QueryLoki(LokiRequest) returns (stream LokiLogMessage) {}\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='syntax = "proto3";\n\npackage pachyderm.worker;', metadata={'source': 'protobufs/main.proto'}), Document(page_content='option go_package = "github.com/pachyderm/pachyderm/v2/src/worker";\n\nimport "pps/pps.proto";\nimport "gogoproto/gogo.proto";\nimport "google/protobuf/empty.proto";', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message CancelRequest {\n  string job_id = 1 [(gogoproto.customname) = "JobID"];\n  repeated string data_filters = 2;\n}\n\nmessage CancelResponse {\n  bool success = 1;\n}\n\n// Error indicates that the processing of the current datum errored.\n// Datum error semantics with datum batching enabled are similar to datum error\n// semantics without datum batching enabled in that the datum may be retried,\n// recovered, or result with a job failure.\nmessage NextDatumRequest {\n  string error = 1;\n}\n\n// Env is a list of environment variables that should be set for the processing\n// of the next datum.', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message NextDatumResponse {\n  repeated string env = 1;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content="service Worker {\n  rpc Status(google.protobuf.Empty) returns (pps_v2.WorkerStatus) {}\n  rpc Cancel(CancelRequest) returns (CancelResponse) {}\n  // NextDatum should only be called by user code running in a pipeline with\n  // datum batching enabled.\n  // NextDatum will signal to the worker code that the user code is ready to\n  // proceed to the next datum. This generally means setting up the next\n  // datum's filesystem state and updating internal metadata similarly to datum\n  // processing in a normal pipeline.\n  // NextDatum is a synchronous operation, so user code should expect to block", metadata={'source': 'protobufs/main.proto'}), Document(page_content='// on this until the next datum is set up for processing.\n  // User code should generally be migratable to datum batching by wrapping it\n  // in a loop that calls next datum.\n  rpc NextDatum(NextDatumRequest) returns (NextDatumResponse) {}\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='syntax = "proto3";\n\npackage debug_v2;', metadata={'source': 'protobufs/main.proto'}), Document(page_content='option go_package = "github.com/pachyderm/pachyderm/v2/src/debug";\n\nimport "google/protobuf/wrappers.proto";\nimport "google/protobuf/duration.proto";\n\nimport "pps/pps.proto";', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message ProfileRequest {\n  Profile profile = 1;\n  Filter filter = 2;\n}\n\nmessage Profile {\n    string name = 1;\n    google.protobuf.Duration duration = 2; // only meaningful if name == "cpu"\n}\n\nmessage Filter {\n  oneof filter {\n    bool pachd = 1;\n    pps_v2.Pipeline pipeline = 2;\n    Worker worker = 3;\n    bool database = 4;\n  }\n}\n\nmessage Worker {\n   string pod = 1;\n   bool redirected = 2;\n}\n\nmessage BinaryRequest {\n  Filter filter = 1;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message BinaryRequest {\n  Filter filter = 1;\n}\n\nmessage DumpRequest {\n  Filter filter = 1;\n  // Limit sets the limit for the number of commits / jobs that are returned for each repo / pipeline in the dump.\n  int64 limit = 2;\n}\n\nmessage SetLogLevelRequest {\n    enum LogLevel {\n      UNKNOWN = 0;\n      DEBUG = 1;\n      INFO = 2;\n      ERROR = 3;\n      OFF = 4; // Only GRPC logs can be turned off.\n    };\n    oneof level {\n      LogLevel pachyderm = 1;\n      LogLevel grpc = 2;\n    };\n    google.protobuf.Duration duration = 3;\n    bool recurse = 4;\n}', metadata={'source': 'protobufs/main.proto'}), Document(page_content='message SetLogLevelResponse {\n    repeated string affected_pods = 1;\n    repeated string errored_pods = 2;\n}\n\nservice Debug {\n  rpc Profile(ProfileRequest) returns (stream google.protobuf.BytesValue) {}\n  rpc Binary(BinaryRequest) returns (stream google.protobuf.BytesValue) {}\n  rpc Dump(DumpRequest) returns (stream google.protobuf.BytesValue) {}\n  rpc SetLogLevel(SetLogLevelRequest) returns (SetLogLevelResponse) {}\n}', metadata={'source': 'protobufs/main.proto'})]


[Document(page_content='syntax = "proto3";\n\npackage pfsload;\noption go_package = "github.com/pachyderm/pachyderm/v2/src/internal/pfsload";\n\nimport "pfs/pfs.proto";\n\nmessage CommitSpec {\n  int64 count = 1;\n  repeated ModificationSpec modifications = 2;\n  repeated FileSourceSpec file_sources = 3;\n  ValidatorSpec validator = 4;\n}\n\nmessage ModificationSpec {\n  int64 count = 1;\n  PutFileSpec put_file = 2;\n}\n\nmessage PutFileSpec {\n  int64 count = 1;\n  string source = 2;\n}\n\nmessage PutFileTask {\n  int64 count = 1;\n  FileSourceSpec file_source = 2;\n  int64 seed = 3;\n  string auth_token = 4;\n}', metadata={'source': 'protobufs/pfsload.proto'}), Document(page_content='message PutFileTaskResult {\n  string file_set_id = 1;\n  bytes hash = 2;\n}\n\nmessage FileSourceSpec {\n  string name = 1;\n  RandomFileSourceSpec random = 2;\n}\n\nmessage RandomFileSourceSpec {\n  RandomDirectorySpec directory = 1;\n  repeated SizeSpec sizes = 2;\n  bool increment_path = 3;\n}\n\nmessage RandomDirectorySpec {\n  SizeSpec depth = 1;\n  int64 run = 2;\n}\n\nmessage SizeSpec {\n  int64 min_size = 1 [json_name="min"];\n  int64 max_size = 2 [json_name="max"];\n  int64 prob = 3;\n}\n\nmessage ValidatorSpec {\n  FrequencySpec frequency = 1;\n}', metadata={'source': 'protobufs/pfsload.proto'}), Document(page_content='message ValidatorSpec {\n  FrequencySpec frequency = 1;\n}\n\nmessage FrequencySpec {\n  int64 count = 1;\n  int64 prob = 2; \n}\n\nmessage State {\n  message Commit {\n    pfs_v2.Commit commit = 1;\n    bytes hash = 2;\n  }\n  repeated Commit commits = 1;\n}', metadata={'source': 'protobufs/pfsload.proto'})]


[Document(page_content='syntax = "proto3";\n\npackage debug_v2;\noption go_package = "github.com/pachyderm/pachyderm/v2/src/debug";\n\nimport "google/protobuf/wrappers.proto";\nimport "google/protobuf/duration.proto";\n\nimport "pps/pps.proto";\n\nmessage ProfileRequest {\n  Profile profile = 1;\n  Filter filter = 2;\n}\n\nmessage Profile {\n    string name = 1;\n    google.protobuf.Duration duration = 2; // only meaningful if name == "cpu"\n}\n\nmessage Filter {\n  oneof filter {\n    bool pachd = 1;\n    pps_v2.Pipeline pipeline = 2;\n    Worker worker = 3;\n    bool database = 4;\n  }\n}', metadata={'source': 'protobufs/debug.proto'}), Document(page_content='message Worker {\n   string pod = 1;\n   bool redirected = 2;\n}\n\nmessage BinaryRequest {\n  Filter filter = 1;\n}\n\nmessage DumpRequest {\n  Filter filter = 1;\n  // Limit sets the limit for the number of commits / jobs that are returned for each repo / pipeline in the dump.\n  int64 limit = 2;\n}', metadata={'source': 'protobufs/debug.proto'}), Document(page_content='message SetLogLevelRequest {\n    enum LogLevel {\n      UNKNOWN = 0;\n      DEBUG = 1;\n      INFO = 2;\n      ERROR = 3;\n      OFF = 4; // Only GRPC logs can be turned off.\n    };\n    oneof level {\n      LogLevel pachyderm = 1;\n      LogLevel grpc = 2;\n    };\n    google.protobuf.Duration duration = 3;\n    bool recurse = 4;\n}', metadata={'source': 'protobufs/debug.proto'}), Document(page_content='message SetLogLevelResponse {\n    repeated string affected_pods = 1;\n    repeated string errored_pods = 2;\n}\n\nservice Debug {\n  rpc Profile(ProfileRequest) returns (stream google.protobuf.BytesValue) {}\n  rpc Binary(BinaryRequest) returns (stream google.protobuf.BytesValue) {}\n  rpc Dump(DumpRequest) returns (stream google.protobuf.BytesValue) {}\n  rpc SetLogLevel(SetLogLevelRequest) returns (SetLogLevelResponse) {}\n}', metadata={'source': 'protobufs/debug.proto'})]


[Document(page_content='syntax = "proto3";\n\npackage enterprise_v2;\noption go_package = "github.com/pachyderm/pachyderm/v2/src/enterprise";\n\nimport "google/protobuf/timestamp.proto";\n\nimport "protoextensions/log.proto";\n\n// Enterprise data structures\n\n// LicenseRecord is the record we store in etcd for a Pachyderm enterprise\n// token that has been provided to a Pachyderm license server\nmessage LicenseRecord {\n  string activation_code = 1 [(log.half) = true];\n\n  google.protobuf.Timestamp expires = 2;\n}\n\n// EnterpriseConfig is the configuration we store for heartbeating\n// to the license server.', metadata={'source': 'protobufs/enterprise.proto'}), Document(page_content='message EnterpriseConfig {\n  // license_server is the address of the grpc license service\n  string license_server = 1;\n  // id is the unique identifier for this pachd, which is registered\n  // with the license service\n  string id = 2;\n  // secret is a shared secret between this pachd and the license service\n  string secret = 3;\n}\n\n// EnterpriseRecord is a protobuf we cache in etcd to store the\n// enterprise status.', metadata={'source': 'protobufs/enterprise.proto'}), Document(page_content='message EnterpriseRecord {\n  // license is the cached LicenseRecord retrieved from the most recent\n  // heartbeat to the license server.\n  LicenseRecord license = 1;\n\n  // last_heartbeat is the timestamp of the last successful heartbeat\n  // to the license server\n  google.protobuf.Timestamp last_heartbeat = 2;\n\n  // heartbeat_failed is set if the license is still valid, but\n  // the pachd is no longer registered with an enterprise server.\n  // This is the same as the expired state, where auth is locked\n  // but not disabled.\n  bool heartbeat_failed = 3;\n}', metadata={'source': 'protobufs/enterprise.proto'}), Document(page_content='enum State {\n  NONE = 0;\n  ACTIVE = 1;\n  EXPIRED = 2;\n  HEARTBEAT_FAILED = 3;\n}\n\n// TokenInfo contains information about the currently active enterprise token', metadata={'source': 'protobufs/enterprise.proto'}), Document(page_content='message TokenInfo {\n  // expires indicates when the current token expires (unset if there is no\n  // current token)\n  google.protobuf.Timestamp expires = 1;\n}\n\n//// Enterprise Activation API\n\nmessage ActivateRequest {\n  string license_server = 1;\n  string id = 2;\n  string secret = 3 [(log.half) = true];\n}\nmessage ActivateResponse {}\n\nmessage GetStateRequest {}\n\nmessage GetStateResponse {\n  State state = 1;\n  TokenInfo info = 2;\n\n  // activation_code will always be an empty string,\n  // call GetEnterpriseCode to get the activation code\n  string activation_code = 3 [(log.half) = true];\n}', metadata={'source': 'protobufs/enterprise.proto'}), Document(page_content='message GetActivationCodeRequest {}\n\nmessage GetActivationCodeResponse {\n  State state = 1;\n  TokenInfo info = 2;\n  string activation_code = 3 [(log.half) = true];\n}\n\n// Heartbeat in the enterprise service just triggers a heartbeat for\n// testing purposes. The RPC used to communicate with the license\n// service is defined in the license service.\nmessage HeartbeatRequest{}\nmessage HeartbeatResponse{}\n\nmessage DeactivateRequest{}\nmessage DeactivateResponse{}\n\nmessage PauseRequest{}\nmessage PauseResponse{}\n\nmessage UnpauseRequest{}\nmessage UnpauseResponse{}\n\nmessage PauseStatusRequest{}', metadata={'source': 'protobufs/enterprise.proto'}), Document(page_content='message PauseStatusResponse{\n  enum PauseStatus {\n    UNPAUSED = 0;\n    PARTIALLY_PAUSED = 1;\n    PAUSED = 2;\n  }\n  PauseStatus status = 1;\n}', metadata={'source': 'protobufs/enterprise.proto'}), Document(page_content='service API {\n  // Provide a Pachyderm enterprise token, enabling Pachyderm enterprise\n  // features, such as the Pachyderm Dashboard and Auth system\n  rpc Activate(ActivateRequest) returns (ActivateResponse) {}\n  rpc GetState(GetStateRequest) returns (GetStateResponse) {}\n  rpc GetActivationCode(GetActivationCodeRequest) returns (GetActivationCodeResponse) {}\n\n  // Heartbeat is used in testing to trigger a heartbeat on demand. Normally this happens\n  // on a timer.\n  rpc Heartbeat(HeartbeatRequest) returns (HeartbeatResponse) {}', metadata={'source': 'protobufs/enterprise.proto'}), Document(page_content="// Deactivate removes a cluster's enterprise activation\n  // token and sets its enterprise state to NONE.\n  rpc Deactivate(DeactivateRequest) returns (DeactivateResponse) {}\n\n  // Pause pauses the cluster.\n  rpc Pause(PauseRequest) returns (PauseResponse) {}\n  // Unpause unpauses the cluser.\n  rpc Unpause(UnpauseRequest) returns (UnpauseResponse) {}\n  rpc PauseStatus(PauseStatusRequest) returns (PauseStatusResponse) {}\n}", metadata={'source': 'protobufs/enterprise.proto'})]


[Document(page_content='syntax = "proto3";\n\npackage chunk;\noption go_package = "github.com/pachyderm/pachyderm/v2/src/internal/storage/chunk";\n\n// DataRef is a reference to data within a chunk.\nmessage DataRef {\n  // The chunk the referenced data is located in.\n  Ref ref = 1;\n  // The hash of the data being referenced.\n  bytes hash = 2;\n  // The offset and size used for accessing the data within the chunk.\n  int64 offset_bytes = 3;\n  int64 size_bytes = 4;\n}\n\nenum CompressionAlgo {\n  NONE = 0;\n  GZIP_BEST_SPEED = 1;  \n}\n\nenum EncryptionAlgo {\n  ENCRYPTION_ALGO_UNKNOWN = 0;\n  CHACHA20 = 1;\n}', metadata={'source': 'protobufs/chunk.proto'}), Document(page_content='message Ref {\n  bytes id = 1;\n  int64 size_bytes = 2;\n  bool edge = 3;\n\n  bytes dek = 4;\n  EncryptionAlgo encryption_algo = 5;\n  CompressionAlgo compression_algo = 6;\n}', metadata={'source': 'protobufs/chunk.proto'})]


[Document(page_content='syntax = "proto3";\n\npackage ppsload;\noption go_package = "github.com/pachyderm/pachyderm/v2/src/internal/ppsload";\n\nimport "pfs/pfs.proto";\n\nmessage State {\n  pfs_v2.Branch branch = 1;\n  string pfs_state_id = 2;\n}', metadata={'source': 'protobufs/ppsload.proto'})]


[Document(page_content='syntax = "proto3";\n\npackage index;\noption go_package = "github.com/pachyderm/pachyderm/v2/src/internal/storage/fileset/index";\n\nimport "internal/storage/chunk/chunk.proto";\n\n// Index stores an index to and metadata about a range of files or a file.\nmessage Index {\n  string path = 1;\n  // NOTE: range and file are mutually exclusive.\n  Range range = 2;\n  File file = 3;\n  // NOTE: num_files and size_bytes did not exist in older versions of 2.x, so\n  // they will not be set.\n  int64 num_files = 4;\n  int64 size_bytes = 5;\n}', metadata={'source': 'protobufs/index.proto'}), Document(page_content='message Range {\n  int64 offset = 1;\n  string last_path = 2;\n  chunk.DataRef chunk_ref = 3;\n}\n\nmessage File {\n  string datum = 1;\n  repeated chunk.DataRef data_refs = 2;\n}', metadata={'source': 'protobufs/index.proto'})]


[Document(page_content='syntax = "proto3";\n\n// Note: etc/proto/protoc-gen-zap/protoextensions needs a version of this file compiled with the\n// non-gogo protobuf compiler: `protoc --proto_path=. --go_out=. src/protoextensions/log.proto`\n// and then copy the generated file out of the github.com/... directory `mv\n// github.com/pachyderm/pachyderm/v2/src/protoextensions/log.pb.go\n// etc/proto/protoc-gen-zap/protoextensions/`.\n\npackage log;', metadata={'source': 'protobufs/log.proto'}), Document(page_content='option go_package = "github.com/pachyderm/pachyderm/v2/src/protoextensions";\n\nimport "google/protobuf/descriptor.proto";\n\nextend google.protobuf.FieldOptions {\n  bool mask = 50001;\n  bool half = 50002;\n}', metadata={'source': 'protobufs/log.proto'})]


[Document(page_content='syntax = "proto3";\n\npackage proxy;\noption go_package = "github.com/pachyderm/pachyderm/v2/src/proxy";\n\nmessage ListenRequest {\n  string channel = 1;\n}\n\nmessage ListenResponse {\n  string extra = 1;\n}\n\nservice API {\n  // Listen streams database events. \n  // It signals that it is internally set up by sending an initial empty ListenResponse.\n  rpc Listen(ListenRequest) returns (stream ListenResponse) {}\n}', metadata={'source': 'protobufs/proxy.proto'})]


[Document(page_content='syntax = "proto3";\n\npackage pfsserver;\noption go_package = "github.com/pachyderm/pachyderm/v2/src/server/pfs/server";\n\nimport "internal/storage/fileset/index/index.proto";\nimport "pfs/pfs.proto";\n\nmessage ShardTask {\n  repeated string inputs = 1;\n  PathRange path_range = 2;\n}\n\nmessage ShardTaskResult {\n  repeated CompactTask compact_tasks = 1;\n}\n\nmessage PathRange {\n  string lower = 1;\n  string upper = 2;\n}\n\nmessage CompactTask {\n  repeated string inputs = 1;\n  PathRange path_range = 2;\n}\n\nmessage CompactTaskResult {\n  string id = 1;\n}\n\nmessage ConcatTask {\n  repeated string inputs = 1;\n}', metadata={'source': 'protobufs/pfsserver.proto'}), Document(page_content='message ConcatTask {\n  repeated string inputs = 1;\n}\n\nmessage ConcatTaskResult {\n  string id = 1;\n}\n\nmessage ValidateTask {\n  string id = 1;\n  PathRange path_range = 2;\n}\n\nmessage ValidateTaskResult {\n  index.Index first = 1;\n  index.Index last = 2;\n  string error = 3;\n  int64 size_bytes = 4;\n}\n\nmessage PutFileURLTask {\n  string dst = 1;\n  string datum = 2;\n  string URL = 3;\n  repeated string paths = 4;\n  int64 start_offset = 5;\n  int64 end_offset = 7;\n}\n\nmessage PutFileURLTaskResult {\n  string id = 1;\n}', metadata={'source': 'protobufs/pfsserver.proto'}), Document(page_content='message PutFileURLTaskResult {\n  string id = 1;\n}\n\nmessage GetFileURLTask {\n  string URL = 1;\n  pfs_v2.File file = 2;\n  pfs_v2.PathRange path_range = 3;\n}\n\nmessage GetFileURLTaskResult {}', metadata={'source': 'protobufs/pfsserver.proto'})]


[Document(page_content='syntax = "proto3";\n\npackage common;\noption go_package = "github.com/pachyderm/pachyderm/v2/src/internal/collection";\n\nimport "gogoproto/gogo.proto";\n\nmessage TestItem {\n  string id = 1 [(gogoproto.customname) = "ID"];\n  string value = 2;\n  string data = 3;\n}', metadata={'source': 'protobufs/test.proto'})]


[Document(page_content='syntax = "proto3";\n\npackage identity_v2;\noption go_package = "github.com/pachyderm/pachyderm/v2/src/identity";\n\nimport "google/protobuf/timestamp.proto";\nimport "google/protobuf/struct.proto";\nimport "gogoproto/gogo.proto";\n\nimport "protoextensions/log.proto";\n\n// User represents an IDP user that has authenticated via OIDC', metadata={'source': 'protobufs/identity.proto'}), Document(page_content='message User {\n  string email = 1;\n  google.protobuf.Timestamp last_authenticated = 2 [(gogoproto.moretags) = "db:\\"last_authenticated\\"", (gogoproto.stdtime) = true];\n}\n\n// IdentityServerConfig is the configuration for the identity web server.\n// When the configuration is changed the web server is reloaded automatically.\nmessage IdentityServerConfig {\n  string issuer = 1;\n  string id_token_expiry = 2 [(gogoproto.moretags) = "db:\\"id_token_expiry\\""];\n  string rotation_token_expiry = 3 [(gogoproto.moretags) = "db:\\"rotation_token_expiry\\""];\n}', metadata={'source': 'protobufs/identity.proto'}), Document(page_content='message SetIdentityServerConfigRequest {\n  IdentityServerConfig config = 1;\n}\n\nmessage SetIdentityServerConfigResponse {}\n\n\nmessage GetIdentityServerConfigRequest {}\n\nmessage GetIdentityServerConfigResponse {\n  IdentityServerConfig config = 1;\n}\n\n// IDPConnector represents a connection to an identity provider', metadata={'source': 'protobufs/identity.proto'}), Document(page_content="message IDPConnector {\n  // ID is the unique identifier for this connector.\n  string id = 1;\n\n  // Name is the human-readable identifier for this connector,\n  // which will be shown to end users when they're authenticating.\n  string name = 2;\n\n  // Type is the type of the IDP ex. `saml`, `oidc`, `github`.\n  string type = 3;\n\n  // ConfigVersion must be incremented every time a connector is\n  // updated, to avoid concurrent updates conflicting.\n  int64 configVersion = 4;", metadata={'source': 'protobufs/identity.proto'}), Document(page_content='// This is left for backwards compatibility, but we want users to use the config defined below.\n  string jsonConfig = 5 [(log.mask) = true];\n\n  // Config is the configuration for the upstream IDP, which varies based on the type.\n  // We make the assumption that this is either yaml or JSON.\n  google.protobuf.Struct config = 6 [(log.mask) = true];\n}', metadata={'source': 'protobufs/identity.proto'}), Document(page_content='message CreateIDPConnectorRequest {\n  IDPConnector connector = 1;\n}\n\nmessage CreateIDPConnectorResponse {}\n\nmessage UpdateIDPConnectorRequest {\n  IDPConnector connector = 1;\n}\n\nmessage UpdateIDPConnectorResponse {}\n\nmessage ListIDPConnectorsRequest {}\n\nmessage ListIDPConnectorsResponse {\n  repeated IDPConnector connectors = 1;\n}\n\nmessage GetIDPConnectorRequest {\n  string id = 1;\n}\n\nmessage GetIDPConnectorResponse {\n  IDPConnector connector = 1;\n}\n\nmessage DeleteIDPConnectorRequest {\n  string id = 1;\n}\n\nmessage DeleteIDPConnectorResponse {}', metadata={'source': 'protobufs/identity.proto'}), Document(page_content='message DeleteIDPConnectorResponse {}\n\nmessage OIDCClient {\n  string id = 1;\n  repeated string redirect_uris = 2;\n  repeated string trusted_peers = 3;\n  string name = 4;\n  string secret = 5 [(log.mask) = true];\n}\n\nmessage CreateOIDCClientRequest {\n  OIDCClient client = 1;\n}\n\nmessage CreateOIDCClientResponse {\n  OIDCClient client = 1;\n}\n\nmessage GetOIDCClientRequest {\n  string id = 1;\n}\n\nmessage GetOIDCClientResponse {\n  OIDCClient client = 1;\n}\n\nmessage ListOIDCClientsRequest {}\n\nmessage ListOIDCClientsResponse {\n  repeated OIDCClient clients = 1;\n}', metadata={'source': 'protobufs/identity.proto'}), Document(page_content='message UpdateOIDCClientRequest {\n  OIDCClient client = 1;\n}\n\nmessage UpdateOIDCClientResponse {}\n\nmessage DeleteOIDCClientRequest {\n  string id = 1;\n}\n\nmessage DeleteOIDCClientResponse {}\n\nmessage DeleteAllRequest {}', metadata={'source': 'protobufs/identity.proto'}), Document(page_content='message DeleteAllResponse {}', metadata={'source': 'protobufs/identity.proto'}), Document(page_content='service API {\n  rpc SetIdentityServerConfig(SetIdentityServerConfigRequest) returns (SetIdentityServerConfigResponse) {}\n  rpc GetIdentityServerConfig(GetIdentityServerConfigRequest) returns (GetIdentityServerConfigResponse) {}\n  rpc CreateIDPConnector(CreateIDPConnectorRequest) returns (CreateIDPConnectorResponse) {}\n  rpc UpdateIDPConnector(UpdateIDPConnectorRequest) returns (UpdateIDPConnectorResponse) {}\n  rpc ListIDPConnectors(ListIDPConnectorsRequest) returns (ListIDPConnectorsResponse) {}\n  rpc GetIDPConnector(GetIDPConnectorRequest) returns (GetIDPConnectorResponse) {}', metadata={'source': 'protobufs/identity.proto'}), Document(page_content='rpc DeleteIDPConnector(DeleteIDPConnectorRequest) returns (DeleteIDPConnectorResponse) {}\n  rpc CreateOIDCClient(CreateOIDCClientRequest) returns (CreateOIDCClientResponse) {}\n  rpc UpdateOIDCClient(UpdateOIDCClientRequest) returns (UpdateOIDCClientResponse) {}\n  rpc GetOIDCClient(GetOIDCClientRequest) returns (GetOIDCClientResponse) {}\n  rpc ListOIDCClients(ListOIDCClientsRequest) returns (ListOIDCClientsResponse) {}\n  rpc DeleteOIDCClient(DeleteOIDCClientRequest) returns (DeleteOIDCClientResponse) {}\n  rpc DeleteAll(DeleteAllRequest) returns (DeleteAllResponse) {}\n}', metadata={'source': 'protobufs/identity.proto'})]


[Document(page_content='syntax = "proto3";\n\nimport "google/protobuf/empty.proto";\n\npackage versionpb_v2;\noption go_package = "github.com/pachyderm/pachyderm/v2/src/version/versionpb";\n\nmessage Version {\n  uint32 major = 1;\n  uint32 minor = 2;\n  uint32 micro = 3;\n  string additional = 4;\n  string git_commit = 5;\n  string git_tree_modified = 6;\n  string build_date = 7;\n  string go_version = 8;\n  string platform = 9;\n}\n\nservice API {\n  rpc GetVersion(google.protobuf.Empty) returns (Version) {}\n}', metadata={'source': 'protobufs/version.proto'})]


[Document(page_content='syntax = "proto3";\n\npackage pps_v2;\noption go_package = "github.com/pachyderm/pachyderm/v2/src/pps";\n\nimport "google/protobuf/empty.proto";\nimport "google/protobuf/timestamp.proto";\nimport "google/protobuf/duration.proto";\nimport "google/protobuf/wrappers.proto";\n\nimport "gogoproto/gogo.proto";\n\nimport "pfs/pfs.proto";\n\nimport "task/task.proto";', metadata={'source': 'protobufs/pps.proto'}), Document(page_content='message SecretMount {\n  // Name must be the name of the secret in kubernetes.\n  string name = 1;\n  // Key of the secret to load into env_var, this field only has meaning if EnvVar != "".\n  string key = 2;\n  string mount_path = 3;\n  string env_var = 4;\n}', metadata={'source': 'protobufs/pps.proto'}), Document(page_content='message Transform {\n  string image = 1;\n  repeated string cmd = 2;\n  repeated string err_cmd = 3;\n  map<string, string> env = 4;\n  repeated SecretMount secrets = 5;\n  repeated string image_pull_secrets = 6;\n  repeated string stdin = 7;\n  repeated string err_stdin = 8;\n  repeated int64 accept_return_code = 9;\n  bool debug = 10;\n  string user = 11;\n  string working_dir = 12;\n  string dockerfile = 13;\n  bool memory_volume = 14;\n  bool datum_batching = 15;\n}', metadata={'source': 'protobufs/pps.proto'}), Document(page_content='message TFJob {\n  // tf_job  is a serialized Kubeflow TFJob spec. Pachyderm sends this directly\n  // to a kubernetes cluster on which kubeflow has been installed, instead of\n  // creating a pipeline ReplicationController as it normally would.\n  string tf_job = 1 [(gogoproto.customname) = "TFJob"];\n}\n\nmessage Egress {\n  string URL = 1;\n  oneof target {\n    pfs_v2.ObjectStorageEgress object_storage = 2;\n    pfs_v2.SQLDatabaseEgress sql_database = 3;\n  }\n}', metadata={'source': 'protobufs/pps.proto'}), Document(page_content='message Job {\n  Pipeline pipeline = 1;\n  string id = 2 [(gogoproto.customname) = "ID"];\n}\n\nenum JobState {\n  JOB_STATE_UNKNOWN = 0;\n  JOB_CREATED = 1;\n  JOB_STARTING = 2;\n  JOB_RUNNING = 3;\n  JOB_FAILURE = 4;\n  JOB_SUCCESS = 5;\n  JOB_KILLED = 6;\n  JOB_EGRESSING = 7;\n  JOB_FINISHING = 8;\n  JOB_UNRUNNABLE = 9;\n}\n\nmessage Metadata {\n  map<string, string> annotations = 1;\n  map<string, string> labels = 2;\n}\n\nmessage Service {\n  int32 internal_port = 1;\n  int32 external_port = 2;\n  string ip = 3 [(gogoproto.customname) = "IP"];\n  string type = 4;\n}\n\nmessage Spout {\n  Service service = 1;\n}', metadata={'source': 'protobufs/pps.proto'}), Document(page_content='message PFSInput {\n  string project = 14;\n  string name = 1;\n  string repo = 2;\n  string repo_type = 13;\n  string branch = 3;\n  string commit = 4;\n  string glob = 5;\n  string join_on = 6;\n  bool outer_join = 7;\n  string group_by = 8;\n  bool lazy = 9;\n  // EmptyFiles, if true, will cause files from this PFS input to be\n  // presented as empty files. This is useful in shuffle pipelines where you\n  // want to read the names of files and reorganize them using symlinks.\n  bool empty_files = 10;\n  // S3, if true, will cause the worker to NOT download or link files from this', metadata={'source': 'protobufs/pps.proto'}), Document(page_content="// input into the /pfs_v2 directory. Instead, an instance of our S3 gateway\n  // service will run on each of the sidecars, and data can be retrieved from\n  // this input by querying\n  // http://<pipeline>-s3.<namespace>/<job id>.<input>/my/file\n  bool s3 = 11;\n  // Trigger defines when this input is processed by the pipeline, if it's nil\n  // the input is processed anytime something is committed to the input branch.\n  pfs_v2.Trigger trigger = 12;\n}", metadata={'source': 'protobufs/pps.proto'}), Document(page_content='message CronInput {\n  string name = 1;\n  string project = 7;\n  string repo = 2;\n  string commit = 3;\n  string spec = 4;\n  // Overwrite, if true, will expose a single datum that gets overwritten each\n  // tick. If false, it will create a new datum for each tick.\n  bool overwrite = 5;\n  google.protobuf.Timestamp start = 6;\n}\n\n\nmessage Input {\n  PFSInput pfs = 1;\n  repeated Input join = 2;\n  repeated Input group = 3;\n  repeated Input cross = 4;\n  repeated Input union = 5;\n  CronInput cron = 6;\n}', metadata={'source': 'protobufs/pps.proto'}), Document(page_content="message JobInput {\n  string name = 1;\n  pfs_v2.Commit commit = 2;\n  string glob = 3;\n  bool lazy = 4;\n}\n\nmessage ParallelismSpec {\n  // Starts the pipeline/job with a 'constant' workers, unless 'constant' is\n  // zero. If 'constant' is zero (which is the zero value of ParallelismSpec),\n  // then Pachyderm will choose the number of workers that is started,\n  // (currently it chooses the number of workers in the cluster)\n  uint64 constant = 1;\n}\n\nmessage InputFile {\n  // This file's absolute path within its pfs repo.\n  string path = 1;\n\n  // This file's hash\n  bytes hash = 2;\n}", metadata={'source': 'protobufs/pps.proto'}), Document(page_content='message Datum {\n  // ID is the hash computed from all the files\n  Job job = 1;\n  string id = 2 [(gogoproto.customname) = "ID"];\n}\n\nenum DatumState {\n  UNKNOWN = 0; // or not part of a job\n  FAILED = 1;\n  SUCCESS = 2;\n  SKIPPED = 3;\n  STARTING = 4;\n  RECOVERED = 5;\n}\n\nmessage DatumInfo {\n  Datum datum = 1;\n  DatumState state = 2;\n  ProcessStats stats = 3;\n  pfs_v2.File pfs_state = 4;\n  repeated pfs_v2.FileInfo data = 5;\n  string image_id = 6;\n}\n\nmessage Aggregate {\n  int64 count = 1;\n  double mean = 2;\n  double stddev = 3;\n  double fifth_percentile = 4;\n  double ninety_fifth_percentile = 5;\n}', metadata={'source': 'protobufs/pps.proto'}), Document(page_content='message ProcessStats {\n  google.protobuf.Duration download_time = 1;\n  google.protobuf.Duration process_time = 2;\n  google.protobuf.Duration upload_time = 3;\n  int64 download_bytes = 4;\n  int64 upload_bytes = 5;\n}\n\nmessage AggregateProcessStats {\n  Aggregate download_time = 1;\n  Aggregate process_time = 2;\n  Aggregate upload_time = 3;\n  Aggregate download_bytes = 4;\n  Aggregate upload_bytes = 5;\n}\n\nmessage WorkerStatus {\n  string worker_id = 1 [(gogoproto.customname) = "WorkerID"];\n  string job_id = 2 [(gogoproto.customname) = "JobID"];\n  DatumStatus datum_status = 3;\n}', metadata={'source': 'protobufs/pps.proto'}), Document(page_content='message DatumStatus {\n  // Started is the time processing on the current datum began.\n  google.protobuf.Timestamp started = 1;\n  repeated InputFile data = 2;\n}\n\n// ResourceSpec describes the amount of resources that pipeline pods should\n// request from kubernetes, for scheduling.', metadata={'source': 'protobufs/pps.proto'}), Document(page_content='message ResourceSpec {\n  // The number of CPUs each worker needs (partial values are allowed, and\n  // encouraged)\n  float cpu = 1;\n\n  // The amount of memory each worker needs (in bytes, with allowed\n  // SI suffixes (M, K, G, Mi, Ki, Gi, etc).\n  string memory = 2;\n\n  // The spec for GPU resources.\n  GPUSpec gpu = 3;\n\n  // The amount of ephemeral storage each worker needs (in bytes, with allowed\n  // SI suffixes (M, K, G, Mi, Ki, Gi, etc).\n  string disk = 4;\n}', metadata={'source': 'protobufs/pps.proto'}), Document(page_content="message GPUSpec {\n  // The type of GPU (nvidia.com/gpu or amd.com/gpu for example).\n  string type = 1;\n  // The number of GPUs to request.\n  int64 number = 2;\n}\n\nmessage JobSetInfo {\n  JobSet job_set = 1;\n  repeated JobInfo jobs = 2;\n}\n\n// JobInfo is the data stored in the database regarding a given job.  The\n// 'details' field contains more information about the job which is expensive to\n// fetch, requiring querying workers or loading the pipeline spec from object\n// storage.", metadata={'source': 'protobufs/pps.proto'}), Document(page_content='message JobInfo {\n  Job job = 1;\n  uint64 pipeline_version = 2;\n  pfs_v2.Commit output_commit = 3;\n  // Job restart count (e.g. due to datum failure)\n  uint64 restart = 4;\n\n  // Counts of how many times we processed or skipped a datum\n  int64 data_processed = 5;\n  int64 data_skipped = 6;\n  int64 data_total = 7;\n  int64 data_failed = 8;\n  int64 data_recovered = 9;\n\n  // Download/process/upload time and download/upload bytes\n  ProcessStats stats = 10;', metadata={'source': 'protobufs/pps.proto'}), Document(page_content='JobState state = 11;\n  string reason = 12; // reason explains why the job is in the current state\n  google.protobuf.Timestamp created = 13;\n  google.protobuf.Timestamp started = 14;\n  google.protobuf.Timestamp finished = 15;', metadata={'source': 'protobufs/pps.proto'}), Document(page_content='message Details {\n    Transform transform = 1;\n    ParallelismSpec parallelism_spec = 2;\n    Egress egress = 3;\n    Service service = 4;\n    Spout spout = 5;\n    repeated WorkerStatus worker_status = 6;\n    ResourceSpec resource_requests = 7;\n    ResourceSpec resource_limits = 8;\n    ResourceSpec sidecar_resource_limits = 9;\n    Input input = 10;\n    string salt = 11;\n    DatumSetSpec datum_set_spec = 12;\n    google.protobuf.Duration datum_timeout = 13;\n    google.protobuf.Duration job_timeout = 14;\n    int64 datum_tries = 15;\n    SchedulingSpec scheduling_spec = 16;', metadata={'source': 'protobufs/pps.proto'}), Document(page_content='SchedulingSpec scheduling_spec = 16;\n    string pod_spec = 17;\n    string pod_patch = 18;\n    ResourceSpec sidecar_resource_requests = 19;\n  }\n  Details details = 16;\n}', metadata={'source': 'protobufs/pps.proto'}), Document(page_content='enum WorkerState {\n  WORKER_STATE_UNKNOWN = 0;\n  POD_RUNNING = 1;\n  POD_SUCCESS = 2;\n  POD_FAILED = 3;\n}', metadata={'source': 'protobufs/pps.proto'}), Document(page_content='message Worker {\n  string name = 1;\n  WorkerState state = 2;\n}', metadata={'source': 'protobufs/pps.proto'}), Document(page_content='message Pipeline {\n  pfs_v2.Project project = 2;\n  string name = 1;\n}', metadata={'source': 'protobufs/pps.proto'}), Document(page_content='enum PipelineState {\n  PIPELINE_STATE_UNKNOWN = 0;\n  // There is a PipelineInfo + spec commit, but no RC\n  // This happens when a pipeline has been created but not yet picked up by a\n  // PPS server.\n  PIPELINE_STARTING = 1;\n  // A pipeline has a spec commit and a service + RC\n  // This is the normal state of a pipeline.\n  PIPELINE_RUNNING = 2;\n  // Equivalent to STARTING (there is a PipelineInfo + commit, but no RC)\n  // After some error caused runPipeline to exit, but before the pipeline is\n  // re-run. This is when the exponential backoff is in effect.\n  PIPELINE_RESTARTING = 3;', metadata={'source': 'protobufs/pps.proto'}), Document(page_content="PIPELINE_RESTARTING = 3;\n  // The pipeline has encountered unrecoverable errors and is no longer being\n  // retried. It won't leave this state until the pipeline is updated.\n  PIPELINE_FAILURE = 4;\n  // The pipeline has been explicitly paused by the user (the pipeline spec's\n  // Stopped field should be true if the pipeline is in this state)\n  PIPELINE_PAUSED = 5;\n  // The pipeline is fully functional, but there are no commits to process.\n  PIPELINE_STANDBY = 6;\n  // The pipeline's workers are crashing, or failing to come up, this may", metadata={'source': 'protobufs/pps.proto'}), Document(page_content='// resolve itself, the pipeline may make progress while in this state if the\n  // problem is only being experienced by some workers.\n  PIPELINE_CRASHING = 7;\n}', metadata={'source': 'protobufs/pps.proto'}), Document(page_content='// Toleration is a Kubernetes toleration.', metadata={'source': 'protobufs/pps.proto'}), Document(page_content="message Toleration {\n  // key is the taint key that the toleration applies to.  Empty means match all taint keys.\n  string key = 1;\n  // operator represents a key's relationship to the value.\n  TolerationOperator operator = 2;\n  // value is the taint value the toleration matches to.\n  string value = 3;\n  // effect indicates the taint effect to match.  Empty means match all taint effects.\n  TaintEffect effect = 4;\n  // toleration_seconds represents the period of time the toleration (which must be of effect", metadata={'source': 'protobufs/pps.proto'}), Document(page_content='// NoExecute, otherwise this field is ignored) tolerates the taint.  If not set, tolerate the\n  // taint forever.\n  google.protobuf.Int64Value toleration_seconds = 5;\n}', metadata={'source': 'protobufs/pps.proto'}), Document(page_content="// TolerationOperator relates a Toleration's key to its value.", metadata={'source': 'protobufs/pps.proto'}), Document(page_content='enum TolerationOperator {\n  EMPTY = 0; // K8s doesn\'t have this, but it\'s possible to represent something similar.\n  EXISTS = 1; // "Exists"\n  EQUAL = 2; // "Equal"\n}\n\n// TaintEffect is an effect that can be matched by a toleration.', metadata={'source': 'protobufs/pps.proto'}), Document(page_content='enum TaintEffect {\n  ALL_EFFECTS = 0; // Empty matches all effects.\n  NO_SCHEDULE = 1; // "NoSchedule"\n  PREFER_NO_SCHEDULE = 2; // "PreferNoSchedule"\n  NO_EXECUTE = 3; // "NoExecute"\n}', metadata={'source': 'protobufs/pps.proto'}), Document(page_content="// PipelineInfo is proto for each pipeline that Pachd stores in the\n// database. It tracks the state of the pipeline, and points to its metadata in\n// PFS (and, by pointing to a PFS commit, de facto tracks the pipeline's\n// version).  Any information about the pipeline _not_ stored in the database is\n// in the Details object, which requires fetching the spec from PFS or other\n// potentially expensive operations.", metadata={'source': 'protobufs/pps.proto'}), Document(page_content='message PipelineInfo {\n  Pipeline pipeline = 1;\n  uint64 version = 2;\n  pfs_v2.Commit spec_commit = 3; // The first spec commit for this version of the pipeline\n  bool stopped = 4;\n\n  // state indicates the current state of the pipeline\n  PipelineState state = 5;\n  // reason includes any error messages associated with a failed pipeline\n  string reason = 6;\n\n  reserved 7; // map<int32, int32> job_counts;\n  // last_job_state indicates the state of the most recently created job\n  JobState last_job_state = 8;', metadata={'source': 'protobufs/pps.proto'}), Document(page_content='// parallelism tracks the literal number of workers that this pipeline should\n  // run.\n  uint64 parallelism = 9;\n\n  // The pipeline type is stored here so that we can internally know the type of\n  // the pipeline without loading the spec from PFS.\n  enum PipelineType {\n    PIPELINT_TYPE_UNKNOWN = 0;\n    PIPELINE_TYPE_TRANSFORM = 1;\n    PIPELINE_TYPE_SPOUT = 2;\n    PIPELINE_TYPE_SERVICE = 3;\n  }\n  PipelineType type = 10;\n\n  string auth_token = 11;', metadata={'source': 'protobufs/pps.proto'}), Document(page_content='string auth_token = 11;\n\n  message Details {\n    Transform transform = 1;\n    // tf_job encodes a Kubeflow TFJob spec. Pachyderm uses this to create TFJobs\n    // when running in a kubernetes cluster on which kubeflow has been installed.\n    // Exactly one of \'tf_job\' and \'transform\' should be set\n    TFJob tf_job = 2 [(gogoproto.customname) = "TFJob"];\n    ParallelismSpec parallelism_spec = 3;\n    Egress egress = 4;\n    google.protobuf.Timestamp created_at = 5;\n\n    string recent_error = 6;\n\n    int64 workers_requested = 7;\n    int64 workers_available = 8;', metadata={'source': 'protobufs/pps.proto'}), Document(page_content='string output_branch = 9;\n    ResourceSpec resource_requests = 10;\n    ResourceSpec resource_limits = 11;\n    ResourceSpec sidecar_resource_limits = 12;\n    Input input = 13;\n    string description = 14;\n    string salt = 16;', metadata={'source': 'protobufs/pps.proto'}), Document(page_content='string reason = 17;\n    Service service = 19;\n    Spout spout = 20;\n    DatumSetSpec datum_set_spec = 21;\n    google.protobuf.Duration datum_timeout = 22;\n    google.protobuf.Duration job_timeout = 23;\n    int64 datum_tries = 24;\n    SchedulingSpec scheduling_spec = 25;\n    string pod_spec = 26;\n    string pod_patch = 27;\n    bool s3_out = 28;\n    Metadata metadata = 29;\n    string reprocess_spec = 30;\n    int64 unclaimed_tasks = 31;\n    string worker_rc = 32;\n    bool autoscaling = 33;\n    repeated Toleration tolerations = 34;\n    ResourceSpec sidecar_resource_requests = 35;\n  }', metadata={'source': 'protobufs/pps.proto'}), Document(page_content='ResourceSpec sidecar_resource_requests = 35;\n  }\n  Details details = 12;\n}', metadata={'source': 'protobufs/pps.proto'}), Document(page_content='message PipelineInfos {\n  repeated PipelineInfo pipeline_info = 1;\n}\n\nmessage JobSet {\n  string id = 1 [(gogoproto.customname) = "ID"];\n}\n\nmessage InspectJobSetRequest {\n  JobSet job_set = 1;\n  bool wait = 2; // When true, wait until all jobs in the set are finished\n  bool details = 3;\n}', metadata={'source': 'protobufs/pps.proto'}), Document(page_content="message ListJobSetRequest {\n  bool details = 1;\n  // A list of projects to filter jobs on, nil means don't filter.\n  repeated pfs_v2.Project projects = 2;\n  // we return job sets created before or after this time based on the reverse flag\n  google.protobuf.Timestamp paginationMarker = 3;\n  // number of results to return\n  int64 number = 4;\n  // if true, return results in reverse order\n  bool reverse = 5;\n}", metadata={'source': 'protobufs/pps.proto'}), Document(page_content='message InspectJobRequest {\n  // Callers should set either Job or OutputCommit, not both.\n  Job job = 1;\n  bool wait = 2; // wait until state is either FAILURE or SUCCESS\n  bool details = 3;\n}', metadata={'source': 'protobufs/pps.proto'}), Document(page_content="message ListJobRequest {\n  // A list of projects to filter jobs on, nil means don't filter.\n  repeated pfs_v2.Project projects = 7;\n  Pipeline pipeline = 1;                // nil means all pipelines\n  repeated pfs_v2.Commit input_commit = 2; // nil means all inputs\n\n  // History indicates return jobs from historical versions of pipelines\n  // semantics are:\n  // 0: Return jobs from the current version of the pipeline or pipelines.\n  // 1: Return the above and jobs from the next most recent version\n  // 2: etc.\n  //-1: Return jobs from all historical versions.\n  int64 history = 4;", metadata={'source': 'protobufs/pps.proto'}), Document(page_content='// Details indicates whether the result should include all pipeline details in\n  // each JobInfo, or limited information including name and status, but\n  // excluding information in the pipeline spec. Leaving this "false" can make\n  // the call significantly faster in clusters with a large number of pipelines\n  // and jobs.\n  // Note that if \'input_commit\' is set, this field is coerced to "true"\n  bool details = 5;\n\n  // A jq program string for additional result filtering\n  string jqFilter = 6;\n\n  // timestamp that is pagination marker\n  google.protobuf.Timestamp paginationMarker = 8;', metadata={'source': 'protobufs/pps.proto'}), Document(page_content='// number of results to return\n  int64 number = 9;\n\n  // flag to indicated if results should be returned in reverse order\n  bool reverse = 10;\n}\n\n// Streams open jobs until canceled', metadata={'source': 'protobufs/pps.proto'}), Document(page_content='message SubscribeJobRequest {\n  Pipeline pipeline = 1;\n  bool details = 2; // Same as ListJobRequest.Details\n}\n\nmessage DeleteJobRequest {\n  Job job = 1;\n}\n\nmessage StopJobRequest {\n  Job job = 1;\n  string reason = 3;\n}\n\nmessage UpdateJobStateRequest {\n  Job job = 1;\n  JobState state = 2;\n  string reason = 3;\n  uint64 restart = 5;\n  int64 data_processed = 6;\n  int64 data_skipped = 7;\n  int64 data_failed = 8;\n  int64 data_recovered = 9;\n  int64 data_total = 10;\n  ProcessStats stats = 11;\n}', metadata={'source': 'protobufs/pps.proto'}), Document(page_content="message GetLogsRequest {\n  // The pipeline from which we want to get logs (required if the job in 'job'\n  // was created as part of a pipeline. To get logs from a non-orphan job\n  // without the pipeline that created it, you need to use ElasticSearch).\n  Pipeline pipeline = 1;\n\n  // The job from which we want to get logs.\n  Job job = 2;", metadata={'source': 'protobufs/pps.proto'}), Document(page_content='// Names of input files from which we want processing logs. This may contain\n  // multiple files, to query pipelines that contain multiple inputs. Each\n  // filter may be an absolute path of a file within a pps repo, or it may be\n  // a hash for that file (to search for files at specific versions)\n  repeated string data_filters = 3;\n\n  Datum datum = 4;\n\n  // If true get logs from the master process\n  bool master = 5;\n\n  // Continue to follow new logs as they become available.\n  bool follow = 6;', metadata={'source': 'protobufs/pps.proto'}), Document(page_content='// If nonzero, the number of lines from the end of the logs to return.  Note:\n  // tail applies per container, so you will get tail * <number of pods> total\n  // lines back.\n  int64 tail = 7;\n\n  // UseLokiBackend causes the logs request to go through the loki backend\n  // rather than through kubernetes. This behavior can also be achieved by\n  // setting the LOKI_LOGGING feature flag.\n  bool use_loki_backend = 8;\n\n  // Since specifies how far in the past to return logs from. It defaults to 24 hours.\n  google.protobuf.Duration since = 9;\n}', metadata={'source': 'protobufs/pps.proto'}), Document(page_content='// LogMessage is a log line from a PPS worker, annotated with metadata\n// indicating when and why the line was logged.', metadata={'source': 'protobufs/pps.proto'}), Document(page_content='message LogMessage {\n  // The job and pipeline for which a PFS file is being processed (if the job\n  // is an orphan job, pipeline name and ID will be unset)\n  string project_name = 10;\n  string pipeline_name = 1;\n  string job_id = 2 [(gogoproto.customname) = "JobID"];\n  string worker_id = 3 [(gogoproto.customname) = "WorkerID"];\n  string datum_id = 4 [(gogoproto.customname) = "DatumID"];\n  bool master = 5;\n\n  // The PFS files being processed (one per pipeline/job input)\n  repeated InputFile data = 6;\n\n  // User is true if log message comes from the users code.\n  bool user = 7;', metadata={'source': 'protobufs/pps.proto'}), Document(page_content='// The message logged, and the time at which it was logged\n  google.protobuf.Timestamp ts = 8;\n  string message = 9;\n}', metadata={'source': 'protobufs/pps.proto'}), Document(page_content='message RestartDatumRequest {\n  Job job = 1;\n  repeated string data_filters = 2;\n}\n\nmessage InspectDatumRequest {\n  Datum datum = 1;\n}', metadata={'source': 'protobufs/pps.proto'}), Document(page_content='message ListDatumRequest {\n  // Filter restricts returned DatumInfo messages to those which match\n  // all of the filtered attributes.\n  message Filter {\n    repeated DatumState state = 1;  // Must match one of the given states.\n  }\n  // Job and Input are two different ways to specify the datums you want.\n  // Only one can be set.\n  // Job is the job to list datums from.\n  Job job = 1;\n  // Input is the input to list datums from.\n  // The datums listed are the ones that would be run if a pipeline was created\n  // with the provided input.\n  Input input = 2;\n  Filter filter = 3;', metadata={'source': 'protobufs/pps.proto'}), Document(page_content='Input input = 2;\n  Filter filter = 3;\n  //datum id to start from. we do not include this datum in the response\n  string paginationMarker = 4;\n  // Number of datums to return\n  int64 number = 5;\n  // If true, return datums in reverse order\n  bool reverse = 6;\n}', metadata={'source': 'protobufs/pps.proto'}), Document(page_content='// DatumSetSpec specifies how a pipeline should split its datums into datum sets.', metadata={'source': 'protobufs/pps.proto'}), Document(page_content="message DatumSetSpec {\n  // number, if nonzero, specifies that each datum set should contain `number`\n  // datums. Datum sets may contain fewer if the total number of datums don't\n  // divide evenly.\n  int64 number = 1;\n  // size_bytes, if nonzero, specifies a target size for each datum set.\n  // Datum sets may be larger or smaller than size_bytes, but will usually be\n  // pretty close to size_bytes in size.\n  int64 size_bytes = 2;", metadata={'source': 'protobufs/pps.proto'}), Document(page_content="// per_worker, if nonzero, specifies how many datum sets should be created\n  // for each worker. It can't be set with number or size_bytes.\n  int64 per_worker = 3;\n}", metadata={'source': 'protobufs/pps.proto'}), Document(page_content='message SchedulingSpec {\n  map<string, string> node_selector = 1;\n  string priority_class_name = 2;\n}', metadata={'source': 'protobufs/pps.proto'}), Document(page_content='message CreatePipelineRequest {\n  Pipeline pipeline = 1;\n  // tf_job encodes a Kubeflow TFJob spec. Pachyderm uses this to create TFJobs\n  // when running in a kubernetes cluster on which kubeflow has been installed.\n  // Exactly one of \'tf_job\' and \'transform\' should be set\n  TFJob tf_job = 2 [(gogoproto.customname) = "TFJob"];\n  Transform transform = 3;\n  ParallelismSpec parallelism_spec = 4;\n  Egress egress = 5;\n  bool update = 6;\n  string output_branch = 7;\n  // s3_out, if set, requires a pipeline\'s user to write to its output repo', metadata={'source': 'protobufs/pps.proto'}), Document(page_content="// via Pachyderm's s3 gateway (if set, workers will serve Pachyderm's s3\n  // gateway API at http://<pipeline>-s3.<namespace>/<job id>.out/my/file).\n  // In this mode /pfs_v2/out won't be walked or uploaded, and the s3 gateway\n  // service in the workers will allow writes to the job's output commit\n  bool s3_out = 8;\n  ResourceSpec resource_requests = 9;\n  ResourceSpec resource_limits = 10;\n  ResourceSpec sidecar_resource_limits = 11;\n  Input input = 12;\n  string description = 13;\n  // Reprocess forces the pipeline to reprocess all datums.\n  // It only has meaning if Update is true", metadata={'source': 'protobufs/pps.proto'}), Document(page_content="// It only has meaning if Update is true\n  bool reprocess = 15;\n  Service service = 17;\n  Spout spout = 18;\n  DatumSetSpec datum_set_spec = 19;\n  google.protobuf.Duration datum_timeout = 20;\n  google.protobuf.Duration job_timeout = 21;\n  string salt = 22;\n  int64 datum_tries = 23;\n  SchedulingSpec scheduling_spec = 24;\n  string pod_spec = 25; // deprecated, use pod_patch below\n  string pod_patch = 26; // a json patch will be applied to the pipeline's pod_spec before it's created;\n  pfs_v2.Commit spec_commit = 27;\n  Metadata metadata = 28;\n  string reprocess_spec = 29;", metadata={'source': 'protobufs/pps.proto'}), Document(page_content='Metadata metadata = 28;\n  string reprocess_spec = 29;\n  bool autoscaling = 30;\n  repeated Toleration tolerations = 34;\n  ResourceSpec sidecar_resource_requests = 35;\n}', metadata={'source': 'protobufs/pps.proto'}), Document(page_content='message InspectPipelineRequest {\n  Pipeline pipeline = 1;\n  // When true, return PipelineInfos with the details field, which requires\n  // loading the pipeline spec from PFS.\n  bool details = 2;\n}', metadata={'source': 'protobufs/pps.proto'}), Document(page_content='message ListPipelineRequest {\n  // If non-nil, only return info about a single pipeline, this is redundant\n  // with InspectPipeline unless history is non-zero.\n  Pipeline pipeline = 1;\n  // History indicates how many historical versions you want returned. Its\n  // semantics are:\n  // 0: Return the current version of the pipeline or pipelines.\n  // 1: Return the above and the next most recent version\n  // 2: etc.\n  //-1: Return all historical versions.\n  int64 history = 2;', metadata={'source': 'protobufs/pps.proto'}), Document(page_content='// When true, return PipelineInfos with the details field, which requires\n  // loading the pipeline spec from PFS.\n  bool details = 3;\n\n  // A jq program string for additional result filtering\n  string jqFilter = 4;\n\n  // If non-nil, will return all the pipeline infos at this commit set\n  pfs_v2.CommitSet commit_set = 5;\n\n  // Projects to filter on. Empty list means no filter, so return all pipelines.\n  repeated pfs_v2.Project projects = 6;\n}\n\n// Delete a pipeline.  If the deprecated all member is true, then delete all\n// pipelines in the default project.', metadata={'source': 'protobufs/pps.proto'}), Document(page_content='message DeletePipelineRequest {\n  Pipeline pipeline = 1;\n  bool all = 2 [deprecated = true];\n  bool force = 3;\n  bool keep_repo = 4;\n}\n\n// Delete more than one pipeline.\nmessage DeletePipelinesRequest {\n  // All pipelines in each project will be deleted if the caller has\n  // permission.\n  repeated pfs_v2.Project projects = 1;\n  bool force = 2;\n  bool keep_repo = 3;\n  // If set, all pipelines in all projects will be deleted if the caller has\n  // permission.\n  bool all = 4;\n}\n\nmessage DeletePipelinesResponse {\n  repeated Pipeline pipelines = 1;\n}', metadata={'source': 'protobufs/pps.proto'}), Document(page_content='message StartPipelineRequest {\n  Pipeline pipeline = 1;\n}\n\nmessage StopPipelineRequest {\n  Pipeline pipeline = 1;\n}\n\nmessage RunPipelineRequest {\n  Pipeline pipeline = 1;\n  repeated pfs_v2.Commit provenance = 2;\n  string job_id = 3 [(gogoproto.customname) = "JobID"];\n}\n\nmessage RunCronRequest {\n  Pipeline pipeline = 1;\n}\n\nmessage CreateSecretRequest {\n  bytes file = 1;\n}\n\nmessage DeleteSecretRequest {\n  Secret secret = 1;\n}\n\nmessage InspectSecretRequest {\n  Secret secret = 1;\n}\n\nmessage Secret {\n  string name = 1;\n}', metadata={'source': 'protobufs/pps.proto'}), Document(page_content='message Secret {\n  string name = 1;\n}\n\nmessage SecretInfo {\n  Secret secret = 1;\n  string type = 2;\n  google.protobuf.Timestamp creation_timestamp = 3;\n}\n\nmessage SecretInfos {\n  repeated SecretInfo secret_info = 1;\n}\n\nmessage ActivateAuthRequest {}\nmessage ActivateAuthResponse {}\n\nmessage RunLoadTestRequest {\n  string dag_spec = 1;\n  string load_spec = 2;\n  int64 seed = 3;\n  int64 parallelism = 4;\n  string pod_patch = 5;\n  string state_id = 6;\n}\n\nmessage RunLoadTestResponse {\n  string error = 1;\n  string state_id = 2;\n}', metadata={'source': 'protobufs/pps.proto'}), Document(page_content='message RenderTemplateRequest {\n  string template = 1;\n  map<string, string> args = 2;\n}\n\nmessage RenderTemplateResponse {\n  string json = 1;\n  repeated CreatePipelineRequest specs = 2;\n}\n\nmessage LokiRequest {\n  google.protobuf.Duration since = 1;\n  string query = 2;\n}', metadata={'source': 'protobufs/pps.proto'}), Document(page_content='message LokiLogMessage {\n  string message = 1;\n}', metadata={'source': 'protobufs/pps.proto'}), Document(page_content='service API {\n  rpc InspectJob(InspectJobRequest) returns (JobInfo) {}\n  rpc InspectJobSet(InspectJobSetRequest) returns (stream JobInfo) {}\n  // ListJob returns information about current and past Pachyderm jobs.\n  rpc ListJob(ListJobRequest) returns (stream JobInfo) {}\n  rpc ListJobSet(ListJobSetRequest) returns (stream JobSetInfo) {}\n  rpc SubscribeJob(SubscribeJobRequest) returns (stream JobInfo) {}\n  rpc DeleteJob(DeleteJobRequest) returns (google.protobuf.Empty) {}\n  rpc StopJob(StopJobRequest) returns (google.protobuf.Empty) {}', metadata={'source': 'protobufs/pps.proto'}), Document(page_content='rpc InspectDatum(InspectDatumRequest) returns (DatumInfo) {}\n  // ListDatum returns information about each datum fed to a Pachyderm job\n  rpc ListDatum(ListDatumRequest) returns (stream DatumInfo) {}\n  rpc RestartDatum(RestartDatumRequest) returns (google.protobuf.Empty) {}', metadata={'source': 'protobufs/pps.proto'}), Document(page_content='rpc CreatePipeline(CreatePipelineRequest) returns (google.protobuf.Empty) {}\n  rpc InspectPipeline(InspectPipelineRequest) returns (PipelineInfo) {}\n  rpc ListPipeline(ListPipelineRequest) returns (stream PipelineInfo) {}\n  rpc DeletePipeline(DeletePipelineRequest) returns (google.protobuf.Empty) {}\n  rpc DeletePipelines(DeletePipelinesRequest) returns (DeletePipelinesResponse) {}\n  rpc StartPipeline(StartPipelineRequest) returns (google.protobuf.Empty) {}\n  rpc StopPipeline(StopPipelineRequest) returns (google.protobuf.Empty) {}', metadata={'source': 'protobufs/pps.proto'}), Document(page_content='rpc RunPipeline(RunPipelineRequest) returns (google.protobuf.Empty) {}\n  rpc RunCron(RunCronRequest) returns (google.protobuf.Empty) {}', metadata={'source': 'protobufs/pps.proto'}), Document(page_content='rpc CreateSecret(CreateSecretRequest) returns (google.protobuf.Empty) {}\n  rpc DeleteSecret(DeleteSecretRequest) returns (google.protobuf.Empty) {}\n  rpc ListSecret(google.protobuf.Empty) returns (SecretInfos) {}\n  rpc InspectSecret(InspectSecretRequest) returns (SecretInfo) {}\n\n  // DeleteAll deletes everything\n  rpc DeleteAll(google.protobuf.Empty) returns (google.protobuf.Empty) {}\n  rpc GetLogs(GetLogsRequest) returns (stream LogMessage) {}', metadata={'source': 'protobufs/pps.proto'}), Document(page_content='// An internal call that causes PPS to put itself into an auth-enabled state\n  // (all pipeline have tokens, correct permissions, etcd)\n  rpc ActivateAuth(ActivateAuthRequest) returns (ActivateAuthResponse) {}\n\n  // An internal call used to move a job from one state to another\n  rpc UpdateJobState(UpdateJobStateRequest) returns(google.protobuf.Empty) {}\n\n  // RunLoadTest runs a load test.\n  rpc RunLoadTest(RunLoadTestRequest) returns (RunLoadTestResponse) {}\n  // RunLoadTestDefault runs the default load test.\n  rpc RunLoadTestDefault(google.protobuf.Empty) returns (RunLoadTestResponse) {}', metadata={'source': 'protobufs/pps.proto'}), Document(page_content='// RenderTemplate renders the provided template and arguments into a list of Pipeline specicifications\n  rpc RenderTemplate(RenderTemplateRequest) returns (RenderTemplateResponse) {}\n\n  // ListTask lists PPS tasks\n  rpc ListTask(taskapi.ListTaskRequest) returns (stream taskapi.TaskInfo) {}\n\n  // GetKubeEvents returns a stream of kubernetes events\n  rpc GetKubeEvents(LokiRequest) returns (stream LokiLogMessage) {}\n\n  // QueryLoki returns a stream of loki log messages given a query string\n  rpc QueryLoki(LokiRequest) returns (stream LokiLogMessage) {}\n}', metadata={'source': 'protobufs/pps.proto'})]


[Document(page_content='syntax = "proto3";\n\npackage extended;\noption go_package = "github.com/pachyderm/pachyderm/v2/src/internal/tracing/extended";\n\n// TraceProto contains information identifying a Jaeger trace. It\'s used to\n// propagate traces that follow the lifetime of a long operation (e.g. creating\n// a pipeline or running a job), and which live longer than any single RPC.', metadata={'source': 'protobufs/extended_trace.proto'}), Document(page_content="message TraceProto {\n  // serialized_trace contains the info identifying a trace in Jaeger (a\n  // (trace ID, span ID, sampled) tuple, basically)\n  map<string, string> serialized_trace = 1;\n\n  string project = 3;\n  // pipeline specifies the target pipeline of this trace; this would be set for\n  // a trace created by 'pachctl create-pipeline' or 'pachctl update-pipeline'\n  // and would include the kubernetes RPCs involved in creating a pipeline\n  string pipeline = 2;\n}", metadata={'source': 'protobufs/extended_trace.proto'})]


[Document(page_content='syntax = "proto3";\n\npackage auth_v2;', metadata={'source': 'protobufs/auth.proto'}), Document(page_content='option go_package = "github.com/pachyderm/pachyderm/v2/src/auth";\n\nimport "gogoproto/gogo.proto";\nimport "google/protobuf/timestamp.proto";', metadata={'source': 'protobufs/auth.proto'}), Document(page_content='import "protoextensions/log.proto";', metadata={'source': 'protobufs/auth.proto'}), Document(page_content='/* A note on users\n *\n * In Pachyderm, usernames are structured strings. This makes both\n * our API and our data model more flexible (at the loss of some type safety).\n * Basically, anywhere that Pachyderm refers to a subject (i.e. TokenInfo) or\n * principal (ACL, the \'admins\' collection), that username will have some\n * structured prefix.\n *\n * Note that externally-facing principals ({Get,Set}{Scope,ACL}, ModifyAdmins,\n * ListAdmins) will have their own conventions\n *\n * The current user formats are:\n * 1) Users synced from an identity provider:\n *      "user:username"', metadata={'source': 'protobufs/auth.proto'}), Document(page_content='*      "user:username"\n * 2) Pachyderm robot users:\n *      "robot:robot_user_1"\n * 3) Pachyderm pipelines:\n *      "pipeline:terasort"\n */', metadata={'source': 'protobufs/auth.proto'}), Document(page_content='//// Activation API\n\n// ActivateRequest enables authentication on the cluster. It issues an auth token\n// with no expiration for the irrevocable admin user `pach:root`.', metadata={'source': 'protobufs/auth.proto'}), Document(page_content='message ActivateRequest {\n  // If set, this token is used as the root user login token. Otherwise the root token\n  // is randomly generated and returned in the response.\n  string root_token = 1 [(log.mask) = true];\n}\n\nmessage ActivateResponse {\n  // pach_token authenticates the caller with Pachyderm (if you want to perform\n  // Pachyderm operations after auth has been activated as themselves, you must\n  // present this token along with your regular request)\n  string pach_token = 1 [(log.mask) = true];\n}\n\nmessage DeactivateRequest {}\nmessage DeactivateResponse {}', metadata={'source': 'protobufs/auth.proto'}), Document(page_content="message DeactivateRequest {}\nmessage DeactivateResponse {}\n\nmessage RotateRootTokenRequest {\n  // root_token is used as the new root token value. If it's unset, then a token will be auto-generated.\n  string root_token = 1 [(log.mask) = true];\n}\n\nmessage RotateRootTokenResponse {\n  string root_token = 1 [(log.mask) = true];\n}\n\n// Configure Pachyderm's auth system with an OIDC provider", metadata={'source': 'protobufs/auth.proto'}), Document(page_content='message OIDCConfig{\n  string issuer = 1;\n  string client_id = 2 [(gogoproto.customname) = "ClientID"];\n  string client_secret = 3 [(log.mask) = true];\n  string redirect_uri = 4 [(gogoproto.customname) = "RedirectURI"];\n  repeated string scopes = 5;\n  bool require_email_verified = 6;\n\n // localhost_issuer ignores the contents of the issuer claim and makes all\n // OIDC requests to the embedded OIDC provider. This is necessary to support\n // some network configurations like Minikube.\n bool localhost_issuer = 7;', metadata={'source': 'protobufs/auth.proto'}), Document(page_content="// user_accessible_issuer_host can be set to override the host used\n  // in the OAuth2 authorization URL in case the OIDC issuer isn't\n  // accessible outside the cluster. This requires a fully formed URL with scheme of either http or https.\n  // This is necessary to support some configurations like Minikube.\n  string user_accessible_issuer_host = 8;\n}", metadata={'source': 'protobufs/auth.proto'}), Document(page_content="message GetConfigurationRequest {}\nmessage GetConfigurationResponse {\n  OIDCConfig configuration = 1;\n}\nmessage SetConfigurationRequest {\n  OIDCConfig configuration = 1;\n}\nmessage SetConfigurationResponse {}\n\n//// Authentication data structures\n\n// TokenInfo is the 'value' of an auth token 'key' in the 'tokens' collection", metadata={'source': 'protobufs/auth.proto'}), Document(page_content='message TokenInfo {\n  // Subject (i.e. Pachyderm account) that a given token authorizes.\n  // See the note at the top of the doc for an explanation of subject structure.\n  string subject = 1;\n  google.protobuf.Timestamp expiration = 2 [(gogoproto.moretags) = "db:\\"expiration\\"", (gogoproto.stdtime) = true];\n  string hashed_token = 3 [(gogoproto.moretags) = "db:\\"token_hash\\""];\n}\n\n//// Authentication API', metadata={'source': 'protobufs/auth.proto'}), Document(page_content='message AuthenticateRequest {\n  // Exactly one of \'id_token\' or \'one_time_password\' must be set:\n\n  // This is the session state that Pachyderm creates in order to keep track of\n  // information related to the current OIDC session.\n  string oidc_state = 1 [(gogoproto.customname) = "OIDCState", (log.half) = true];\n\n  // This is an ID Token issued by the OIDC provider.\n  string id_token = 2 [(log.half) = true];\n}', metadata={'source': 'protobufs/auth.proto'}), Document(page_content='message AuthenticateResponse {\n  // pach_token authenticates the caller with Pachyderm (if you want to perform\n  // Pachyderm operations after auth has been activated as themselves, you must\n  // present this token along with your regular request)\n  string pach_token = 1 [(log.mask) = true];\n}\n\nmessage WhoAmIRequest {}\n\nmessage WhoAmIResponse {\n  string username = 1;\n  google.protobuf.Timestamp expiration = 2 [(gogoproto.moretags) = "db:\\"expiration\\"", (gogoproto.stdtime) = true];\n}\n\nmessage GetRolesForPermissionRequest {\n  Permission permission = 1;\n}', metadata={'source': 'protobufs/auth.proto'}), Document(page_content='message GetRolesForPermissionResponse {\n  repeated Role roles = 1;\n}\n\n//// Authorization data structures\n\n// Roles represents the set of roles a principal has\nmessage Roles {\n  map<string, bool> roles = 1;\n}\n\n// RoleBinding represents the set of roles principals have on a given Resource', metadata={'source': 'protobufs/auth.proto'}), Document(page_content='message RoleBinding {\n  // principal -> roles. All principal names include the structured prefix indicating their type.\n  map<string, Roles> entries = 1;\n}\n\n// Permission represents the ability to perform a given operation on a Resource', metadata={'source': 'protobufs/auth.proto'}), Document(page_content='enum Permission {\n  PERMISSION_UNKNOWN = 0;\n\n  CLUSTER_MODIFY_BINDINGS                          = 100;\n  CLUSTER_GET_BINDINGS                             = 101;\n  CLUSTER_GET_PACHD_LOGS                           = 148;\n  CLUSTER_GET_LOKI_LOGS                            = 150;', metadata={'source': 'protobufs/auth.proto'}), Document(page_content='CLUSTER_AUTH_ACTIVATE                            = 102;\n  CLUSTER_AUTH_DEACTIVATE                          = 103;\n  CLUSTER_AUTH_GET_CONFIG                          = 104;\n  CLUSTER_AUTH_SET_CONFIG                          = 105;\n  CLUSTER_AUTH_GET_ROBOT_TOKEN                     = 139;\n  CLUSTER_AUTH_MODIFY_GROUP_MEMBERS                = 109;\n  CLUSTER_AUTH_GET_GROUPS                          = 110;\n  CLUSTER_AUTH_GET_GROUP_USERS                     = 111;\n  CLUSTER_AUTH_EXTRACT_TOKENS                      = 112;\n  CLUSTER_AUTH_RESTORE_TOKEN                       = 113;', metadata={'source': 'protobufs/auth.proto'}), Document(page_content='CLUSTER_AUTH_RESTORE_TOKEN                       = 113;\n  CLUSTER_AUTH_GET_PERMISSIONS_FOR_PRINCIPAL       = 141;\n  CLUSTER_AUTH_DELETE_EXPIRED_TOKENS               = 140;\n  CLUSTER_AUTH_REVOKE_USER_TOKENS                  = 142;\n  CLUSTER_AUTH_ROTATE_ROOT_TOKEN                   = 147;', metadata={'source': 'protobufs/auth.proto'}), Document(page_content='CLUSTER_ENTERPRISE_ACTIVATE            = 114;\n  CLUSTER_ENTERPRISE_HEARTBEAT           = 115;\n  CLUSTER_ENTERPRISE_GET_CODE            = 116;\n  CLUSTER_ENTERPRISE_DEACTIVATE          = 117;\n  CLUSTER_ENTERPRISE_PAUSE               = 149;', metadata={'source': 'protobufs/auth.proto'}), Document(page_content='CLUSTER_IDENTITY_SET_CONFIG            = 118;\n  CLUSTER_IDENTITY_GET_CONFIG            = 119;\n  CLUSTER_IDENTITY_CREATE_IDP            = 120;\n  CLUSTER_IDENTITY_UPDATE_IDP            = 121;\n  CLUSTER_IDENTITY_LIST_IDPS             = 122;\n  CLUSTER_IDENTITY_GET_IDP               = 123;\n  CLUSTER_IDENTITY_DELETE_IDP            = 124;\n  CLUSTER_IDENTITY_CREATE_OIDC_CLIENT    = 125;\n  CLUSTER_IDENTITY_UPDATE_OIDC_CLIENT    = 126;\n  CLUSTER_IDENTITY_LIST_OIDC_CLIENTS     = 127;\n  CLUSTER_IDENTITY_GET_OIDC_CLIENT       = 128;\n  CLUSTER_IDENTITY_DELETE_OIDC_CLIENT    = 129;', metadata={'source': 'protobufs/auth.proto'}), Document(page_content='CLUSTER_DEBUG_DUMP                     = 131;\n\n  CLUSTER_LICENSE_ACTIVATE               = 132;\n  CLUSTER_LICENSE_GET_CODE               = 133;\n  CLUSTER_LICENSE_ADD_CLUSTER            = 134;\n  CLUSTER_LICENSE_UPDATE_CLUSTER         = 135;\n  CLUSTER_LICENSE_DELETE_CLUSTER         = 136;\n  CLUSTER_LICENSE_LIST_CLUSTERS          = 137;\n\n  // TODO(actgardner): Make k8s secrets into nouns and add an Update RPC\n  CLUSTER_CREATE_SECRET  = 143;\n  CLUSTER_LIST_SECRETS   = 144;\n  SECRET_DELETE          = 145;\n  SECRET_INSPECT         = 146;\n\n  CLUSTER_DELETE_ALL             = 138;', metadata={'source': 'protobufs/auth.proto'}), Document(page_content='CLUSTER_DELETE_ALL             = 138;\n\n  REPO_READ                   = 200;\n  REPO_WRITE                  = 201;\n  REPO_MODIFY_BINDINGS        = 202;\n  REPO_DELETE                 = 203;\n  REPO_INSPECT_COMMIT         = 204;\n  REPO_LIST_COMMIT            = 205;\n  REPO_DELETE_COMMIT          = 206;\n  REPO_CREATE_BRANCH          = 207;\n  REPO_LIST_BRANCH            = 208;\n  REPO_DELETE_BRANCH          = 209;\n  REPO_INSPECT_FILE           = 210;\n  REPO_LIST_FILE              = 211;\n  REPO_ADD_PIPELINE_READER    = 212;\n  REPO_REMOVE_PIPELINE_READER = 213;\n  REPO_ADD_PIPELINE_WRITER    = 214;', metadata={'source': 'protobufs/auth.proto'}), Document(page_content='PIPELINE_LIST_JOB     = 301;\n\n  PROJECT_CREATE = 400;\n  PROJECT_DELETE = 401;\n  PROJECT_LIST_REPO = 402;\n  PROJECT_CREATE_REPO = 403;\n  PROJECT_MODIFY_BINDINGS = 404;\n}\n\n// ResourceType represents the type of a Resource', metadata={'source': 'protobufs/auth.proto'}), Document(page_content='enum ResourceType {\n  RESOURCE_TYPE_UNKNOWN = 0;\n  CLUSTER   = 1;\n  REPO      = 2;\n  SPEC_REPO = 3;\n  PROJECT   = 4;\n}\n\n// Resource represents any resource that has role-bindings in the system', metadata={'source': 'protobufs/auth.proto'}), Document(page_content='message Resource {\n  ResourceType type = 1;\n  string name = 2;\n}\n\nmessage Users {\n  map<string, bool> usernames = 1;\n}\n\nmessage Groups {\n  map<string, bool> groups = 1;\n}\n\nmessage Role {\n  string name = 1;\n  repeated Permission permissions = 2;\n  repeated ResourceType resource_types = 3;\n}\n\n//// Authorization API\n\nmessage AuthorizeRequest {\n  Resource resource = 1;\n\n  // permissions are the operations the caller is attempting to perform\n  repeated Permission permissions = 2;\n}', metadata={'source': 'protobufs/auth.proto'}), Document(page_content="message AuthorizeResponse {\n  // authorized is true if the caller has the require permissions\n  bool authorized = 1;\n\n  // satisfied is the set of permission that the principal has\n  repeated Permission satisfied = 2;\n\n  // missing is the set of permissions that the principal lacks\n  repeated Permission missing = 3;\n\n  // principal is the principal the request was evaluated for\n  string principal = 4;\n}\n\n// GetPermissions evaluates the current user's permissions on a resource", metadata={'source': 'protobufs/auth.proto'}), Document(page_content="message GetPermissionsRequest {\n  Resource resource = 1;\n}\n\n// GetPermissionsForPrincipal evaluates an arbitrary principal's permissions\n// on a resource\nmessage GetPermissionsForPrincipalRequest {\n  Resource resource = 1;\n\n  string principal = 2;\n}\n\nmessage GetPermissionsResponse {\n  // permissions is the set of permissions the principal has\n  repeated Permission permissions = 1;\n\n  // roles is the set of roles the principal has\n  repeated string roles = 2;\n}", metadata={'source': 'protobufs/auth.proto'}), Document(page_content='message ModifyRoleBindingRequest {\n  // resource is the resource to modify the role bindings on\n  Resource resource = 1;\n\n  // principal is the principal to modify the roles binding for\n  string principal = 2;\n\n  // roles is the set of roles for principal - an empty list\n  // removes all role bindings\n  repeated string roles = 3;\n}\n\nmessage ModifyRoleBindingResponse {}\n\nmessage GetRoleBindingRequest {\n  Resource resource = 1;\n}', metadata={'source': 'protobufs/auth.proto'}), Document(page_content='message GetRoleBindingResponse {\n  RoleBinding binding = 1;\n}\n\n//////////////////////////////\n//// OIDC Data Structures ////\n//////////////////////////////', metadata={'source': 'protobufs/auth.proto'}), Document(page_content="// SessionInfo stores information associated with one OIDC authentication\n// session (i.e. a single instance of a single user logging in). Sessions are\n// short-lived and stored in the 'oidc-authns' collection, keyed by the OIDC\n// 'state' token (30-character CSPRNG-generated string). 'GetOIDCLogin'\n// generates and inserts entries, then /authorization-code/callback retrieves\n// an access token from the ID provider and uses it to retrive the caller's\n// email and store it in 'email', and finally Authorize() returns a Pachyderm", metadata={'source': 'protobufs/auth.proto'}), Document(page_content='// token identified with that email address as a subject in Pachyderm.', metadata={'source': 'protobufs/auth.proto'}), Document(page_content='message SessionInfo {\n  // nonce is used by /authorization-code/callback to validate session\n  // continuity with the IdP after a user has arrived there from GetOIDCLogin().\n  // This is a 30-character CSPRNG-generated string.\n  string nonce = 1 [(log.half) = true];\n  // email contains the email adddress associated with a user in their OIDC ID\n  // provider. Currently users are identified with their email address rather\n  // than their OIDC subject identifier to make switching between OIDC ID\n  // providers easier for users, and to make user identities more easily', metadata={'source': 'protobufs/auth.proto'}), Document(page_content="// comprehensible in Pachyderm. The OIDC spec doesn't require that users'\n  // emails be present or unique, but we think this will be preferable in\n  // practice.\n  string email = 2;\n  // conversion_err indicates whether an error was encountered while exchanging\n  // an auth code for an access token, or while obtaining a user's email (in\n  // /authorization-code/callback). Storing the error state here allows any\n  // sibling calls to Authenticate() (i.e. using the same OIDC state token) to\n  // notify their caller that an error has occurred. We avoid passing the caller", metadata={'source': 'protobufs/auth.proto'}), Document(page_content='// any details of the error (which are logged by Pachyderm) to avoid giving\n  // information to a user who has network access to Pachyderm but not an\n  // account in the OIDC provider.\n  bool conversion_err = 3;\n}', metadata={'source': 'protobufs/auth.proto'}), Document(page_content='//// OIDC API', metadata={'source': 'protobufs/auth.proto'}), Document(page_content='message GetOIDCLoginRequest {\n}\n\nmessage GetOIDCLoginResponse {\n  // The login URL generated for the OIDC object\n  string login_url = 1 [(gogoproto.customname) = "LoginURL", (log.half) = true];\n  string state = 2 [(log.half) = true];\n}\n\n// Robot token API (TODO: add access controls)\n\nmessage GetRobotTokenRequest {\n  // The returned token will allow the caller to access resources as this\n  // robot user\n  string robot = 1;\n\n  // ttl indicates the requested (approximate) remaining lifetime of this token,\n  // in seconds\n  int64 ttl = 2 [(gogoproto.customname) = "TTL"];\n}', metadata={'source': 'protobufs/auth.proto'}), Document(page_content='message GetRobotTokenResponse {\n  // A new auth token for the requested robot\n  string token = 1 [(log.mask) = true];\n}\n\nmessage RevokeAuthTokenRequest {\n  string token = 1 [(log.half) = true];\n}\n\nmessage RevokeAuthTokenResponse {\n  int64 number = 1;\n}\n\nmessage SetGroupsForUserRequest {\n  string username = 1;\n  repeated string groups = 2;\n}\n\nmessage SetGroupsForUserResponse {}\n\nmessage ModifyMembersRequest {\n  string group = 1;\n  repeated string add = 2;\n  repeated string remove = 3;\n}\n\nmessage ModifyMembersResponse {}\n\nmessage GetGroupsRequest {}', metadata={'source': 'protobufs/auth.proto'}), Document(page_content='message GetGroupsRequest {}\n\nmessage GetGroupsForPrincipalRequest {\n  string principal = 1;\n}\n\nmessage GetGroupsResponse {\n  repeated string groups = 1;\n}\n\nmessage GetUsersRequest {\n  string group = 1;\n}\n\nmessage GetUsersResponse {\n  repeated string usernames = 1;\n}\n\n// ExtractAuthTokens returns all the hashed robot tokens that have been issued.\n// User tokens are not extracted as they can be recreated by logging in.\nmessage ExtractAuthTokensRequest {}', metadata={'source': 'protobufs/auth.proto'}), Document(page_content='message ExtractAuthTokensRequest {}\n\nmessage ExtractAuthTokensResponse {\n  repeated TokenInfo tokens = 1;\n}\n\n// RestoreAuthToken inserts a hashed token that has previously been extracted.\nmessage RestoreAuthTokenRequest {\n  TokenInfo token = 1;\n}\n\nmessage RestoreAuthTokenResponse {}\n\nmessage RevokeAuthTokensForUserRequest {\n  string username = 1;\n}\n\nmessage RevokeAuthTokensForUserResponse {\n  int64 number = 1;\n}\n\nmessage DeleteExpiredAuthTokensRequest {}', metadata={'source': 'protobufs/auth.proto'}), Document(page_content='message DeleteExpiredAuthTokensResponse {}', metadata={'source': 'protobufs/auth.proto'}), Document(page_content="service API {\n  // Activate/Deactivate the auth API. 'Activate' sets an initial set of admins\n  // for the Pachyderm cluster, and 'Deactivate' removes all ACLs, tokens, and\n  // admins from the Pachyderm cluster, making all data publicly accessable\n  rpc Activate(ActivateRequest) returns (ActivateResponse) {}\n  rpc Deactivate(DeactivateRequest) returns (DeactivateResponse) {}\n\n  rpc GetConfiguration(GetConfigurationRequest) returns (GetConfigurationResponse) {}\n  rpc SetConfiguration(SetConfigurationRequest) returns (SetConfigurationResponse) {}", metadata={'source': 'protobufs/auth.proto'}), Document(page_content='rpc Authenticate(AuthenticateRequest) returns (AuthenticateResponse) {}\n  rpc Authorize(AuthorizeRequest) returns (AuthorizeResponse) {}\n  rpc GetPermissions(GetPermissionsRequest) returns (GetPermissionsResponse) {}\n  rpc GetPermissionsForPrincipal(GetPermissionsForPrincipalRequest) returns (GetPermissionsResponse) {}\n  rpc WhoAmI(WhoAmIRequest) returns (WhoAmIResponse) {}\n  rpc GetRolesForPermission(GetRolesForPermissionRequest) returns (GetRolesForPermissionResponse) {}', metadata={'source': 'protobufs/auth.proto'}), Document(page_content='rpc ModifyRoleBinding(ModifyRoleBindingRequest) returns (ModifyRoleBindingResponse) {}\n  rpc GetRoleBinding(GetRoleBindingRequest) returns (GetRoleBindingResponse) {}\n\n  rpc GetOIDCLogin(GetOIDCLoginRequest) returns (GetOIDCLoginResponse) {}\n\n  rpc GetRobotToken(GetRobotTokenRequest) returns (GetRobotTokenResponse) {}\n  rpc RevokeAuthToken(RevokeAuthTokenRequest) returns (RevokeAuthTokenResponse) {}\n  rpc RevokeAuthTokensForUser(RevokeAuthTokensForUserRequest) returns (RevokeAuthTokensForUserResponse) {}', metadata={'source': 'protobufs/auth.proto'}), Document(page_content='rpc SetGroupsForUser(SetGroupsForUserRequest) returns (SetGroupsForUserResponse) {}\n  rpc ModifyMembers(ModifyMembersRequest) returns (ModifyMembersResponse) {}\n  rpc GetGroups(GetGroupsRequest) returns (GetGroupsResponse) {}\n  rpc GetGroupsForPrincipal(GetGroupsForPrincipalRequest) returns (GetGroupsResponse) {}\n  rpc GetUsers(GetUsersRequest) returns (GetUsersResponse) {}\n\n  rpc ExtractAuthTokens(ExtractAuthTokensRequest) returns (ExtractAuthTokensResponse) {}\n  rpc RestoreAuthToken(RestoreAuthTokenRequest) returns (RestoreAuthTokenResponse) {}', metadata={'source': 'protobufs/auth.proto'}), Document(page_content='rpc DeleteExpiredAuthTokens(DeleteExpiredAuthTokensRequest) returns (DeleteExpiredAuthTokensResponse) {}\n  rpc RotateRootToken(RotateRootTokenRequest) returns (RotateRootTokenResponse) {}\n}', metadata={'source': 'protobufs/auth.proto'})]


[Document(page_content='syntax = "proto3";\n\npackage config_v2;', metadata={'source': 'protobufs/config.proto'}), Document(page_content='option go_package = "github.com/pachyderm/pachyderm/v2/src/internal/config";', metadata={'source': 'protobufs/config.proto'}), Document(page_content='import "gogoproto/gogo.proto";\n\n// Config specifies the pachyderm config that is read and interpreted by the\n// pachctl command-line tool. Right now, this is stored at\n// $HOME/.pachyderm/config.\n//\n// Different versions of the pachyderm config are specified as subfields of this\n// message (this allows us to make significant changes to the config structure\n// without breaking existing users by defining a new config version).\n//\n// These structures are stored in a JSON format, so it should be safe to modify\n// fields as long as compatibility is ensured with previous versions.', metadata={'source': 'protobufs/config.proto'}), Document(page_content='message Config {\n    string user_id = 1 [(gogoproto.customname) = "UserID"];\n\n    // Configuration options. Exactly one of these fields should be set\n    // (depending on which version of the config is being used)\n    ConfigV1 v1 = 2;\n    ConfigV2 v2 = 3;\n}\n\n// ConfigV1 specifies v1 of the pachyderm config (June 30 2017 - June 2019)', metadata={'source': 'protobufs/config.proto'}), Document(page_content='message ConfigV1 {\n    // A host:port pointing pachd at a pachyderm cluster.\n    string pachd_address = 1;\n\n    // Trusted root certificates (overrides installed certificates), formatted\n    // as base64-encoded PEM\n    string server_cas = 2 [(gogoproto.customname) = "ServerCAs"];\n\n    // A secret token identifying the current pachctl user within their\n    // pachyderm cluster. This is included in all RPCs sent by pachctl, and used\n    // to determine if pachctl actions are authorized.\n    string session_token = 3;', metadata={'source': 'protobufs/config.proto'}), Document(page_content='// The currently active transaction for batching together pachctl commands.\n    // This can be set or cleared via many of the `pachctl * transaction` commands.\n    // This is the ID of the transaction object stored in the pachyderm etcd.\n    string active_transaction = 4;\n}\n\n// ConfigV2 specifies v2 of the pachyderm config (June 2019 - present)', metadata={'source': 'protobufs/config.proto'}), Document(page_content='message ConfigV2 {\n    string active_context = 1;\n    string active_enterprise_context = 2;\n    map<string, Context> contexts = 3;\n    bool metrics = 4;\n    int64 max_shell_completions = 5;\n}', metadata={'source': 'protobufs/config.proto'}), Document(page_content='message Context {\n    // Where this context came from\n    ContextSource source = 1;\n\n    // The hostname or IP address pointing pachd at a pachyderm cluster.\n    string pachd_address = 2;\n\n    // Trusted root certificates (overrides installed certificates), formatted\n    // as base64-encoded PEM.\n    string server_cas = 3 [(gogoproto.customname) = "ServerCAs"];', metadata={'source': 'protobufs/config.proto'}), Document(page_content='// A secret token identifying the current pachctl user within their\n    // pachyderm cluster. This is included in all RPCs sent by pachctl, and used\n    // to determine if pachctl actions are authorized.\n    string session_token = 4;\n\n    // The currently active transaction for batching together pachctl commands.\n    // This can be set or cleared via many of the `pachctl * transaction` commands.\n    // This is the ID of the transaction object stored in the pachyderm etcd.\n    string active_transaction = 5;', metadata={'source': 'protobufs/config.proto'}), Document(page_content='// The k8s cluster name - used to construct a k8s context.\n    string cluster_name = 6;\n\n    // The k8s auth info - used to construct a k8s context.\n    string auth_info = 7;\n\n    // The k8s namespace - used to construct a k8s context.\n    string namespace = 8;\n\n    // A mapping of service -> port number, when port forwarding is\n    // running for this context.\n    map<string, uint32> port_forwarders = 9;', metadata={'source': 'protobufs/config.proto'}), Document(page_content='// A unique ID for the cluster deployment. At client initialization time,\n    // we ensure this is the same as what the cluster reports back, to prevent\n    // us from connecting to the wrong cluster.\n    string cluster_deployment_id = 10 [(gogoproto.customname) = "ClusterDeploymentID"];\n\n    // A boolean that records whether the context points at an enterprise server.\n    // If false, the context points at a stand-alone pachd.\n    bool enterprise_server = 11;\n\n    // The current project.\n    string project = 12;\n}', metadata={'source': 'protobufs/config.proto'}), Document(page_content='enum ContextSource {\n    NONE = 0;\n    CONFIG_V1 = 1;\n    HUB = 2;\n    IMPORTED = 3;\n}', metadata={'source': 'protobufs/config.proto'})]


[Document(page_content='syntax = "proto3";\n\npackage pfs_v2;\noption go_package = "github.com/pachyderm/pachyderm/v2/src/pfs";\n\nimport "google/protobuf/empty.proto";\nimport "google/protobuf/timestamp.proto";\nimport "google/protobuf/wrappers.proto";\nimport "google/protobuf/duration.proto";\nimport "google/protobuf/any.proto";\n\nimport "gogoproto/gogo.proto";\n\nimport "auth/auth.proto";\n\nimport "task/task.proto";\n\n////  PFS Data structures (stored in etcd)\n\nmessage Repo {\n  string name = 1;\n  string type = 2;\n  Project project = 3;\n}\n\nmessage Branch {\n  Repo repo = 1;\n  string name = 2;\n}', metadata={'source': 'protobufs/pfs.proto'}), Document(page_content='message Branch {\n  Repo repo = 1;\n  string name = 2;\n}\n\nmessage File {\n  Commit commit = 1;\n  string path = 2;\n  string datum = 3;\n}\n\n// RepoInfo is the main data structure representing a Repo in etcd', metadata={'source': 'protobufs/pfs.proto'}), Document(page_content="message RepoInfo {\n  Repo repo = 1;\n  google.protobuf.Timestamp created = 2;\n  int64 size_bytes_upper_bound = 3;\n  string description = 4;\n  repeated Branch branches = 5;\n\n  // Set by ListRepo and InspectRepo if Pachyderm's auth system is active, but\n  // not stored in etcd. To set a user's auth scope for a repo, use the\n  // Pachyderm Auth API (in src/client/auth/auth.proto)\n  AuthInfo auth_info = 6;\n\n  // Details are only provided when explicitly requested\n  message Details {\n    int64 size_bytes = 1;\n  }\n  Details details = 7;\n}", metadata={'source': 'protobufs/pfs.proto'}), Document(page_content="// AuthInfo includes the caller's access scope for a resource, and is returned\n// by services like ListRepo, InspectRepo, and ListProject, but is not persisted in the database.\n// It's used by the Pachyderm dashboard to render repo access appropriately.\n// To set a user's auth scope for a resource, use the Pachyderm Auth API (in src/auth/auth.proto)", metadata={'source': 'protobufs/pfs.proto'}), Document(page_content="message AuthInfo {\n  // The callers access level to the relevant resource. These are very granular\n  // permissions - for the end user it makes sense to show them the roles\n  // they have instead.\n  repeated auth_v2.Permission permissions = 1;\n\n  // The caller's roles on the relevant resource. This includes inherited\n  // roles from the cluster, project, group membership, etc.\n  repeated string roles = 2;\n}", metadata={'source': 'protobufs/pfs.proto'}), Document(page_content='message BranchInfo {\n  Branch branch = 1;\n  Commit head = 2;\n  repeated Branch provenance = 3;\n  repeated Branch subvenance = 4;\n  repeated Branch direct_provenance = 5;\n  Trigger trigger = 6;\n}\n\n// Trigger defines the conditions under which a head is moved, and to which\n// branch it is moved.', metadata={'source': 'protobufs/pfs.proto'}), Document(page_content="message Trigger {\n  // Which branch this trigger refers to\n  string branch = 1;\n  // All indicates that all conditions must be satisfied before the trigger\n  // happens, otherwise any conditions being satisfied will trigger it.\n  bool all = 2;\n  // Triggers if the cron spec has been satisfied since the last trigger and\n  // there's been a new commit.\n  string cron_spec = 3;\n  // Triggers if there's been `size` new data added since the last trigger.\n  string size = 4;\n  // Triggers if there's been `commits` new commits added since the last trigger.\n  int64 commits = 5;\n}", metadata={'source': 'protobufs/pfs.proto'}), Document(page_content='// These are the different places where a commit may be originated from', metadata={'source': 'protobufs/pfs.proto'}), Document(page_content='enum OriginKind {\n  ORIGIN_KIND_UNKNOWN = 0;\n  USER = 1;\n  AUTO = 2;\n  FSCK = 3;\n}', metadata={'source': 'protobufs/pfs.proto'}), Document(page_content='message CommitOrigin {\n  OriginKind kind = 1;\n}\n// Commit is a reference to a commit (e.g. the collection of branches and the\n// collection of currently-open commits in etcd are collections of Commit\n// protos)\nmessage Commit {\n  Repo repo = 3;\n  string id = 2 [(gogoproto.customname) = "ID"];\n  // only used by the client\n  Branch branch = 1;\n}\n\n// CommitInfo is the main data structure representing a commit in etcd', metadata={'source': 'protobufs/pfs.proto'}), Document(page_content='message CommitInfo {\n  reserved 9;\n  Commit commit = 1;\n  CommitOrigin origin = 2;\n  // description is a user-provided script describing this commit\n  string description = 3;\n  Commit parent_commit = 4;\n  repeated Commit child_commits = 5;\n  google.protobuf.Timestamp started = 6;\n  google.protobuf.Timestamp finishing = 7;\n  google.protobuf.Timestamp finished = 8;\n  repeated Commit direct_provenance = 13;\n  string error = 10;\n  int64 size_bytes_upper_bound = 11;', metadata={'source': 'protobufs/pfs.proto'}), Document(page_content='// Details are only provided when explicitly requested\n  message Details {\n    int64 size_bytes = 1;\n    google.protobuf.Duration compacting_time = 2;\n    google.protobuf.Duration validating_time = 3;\n  }\n  Details details = 12;\n}', metadata={'source': 'protobufs/pfs.proto'}), Document(page_content='message CommitSet {\n  string id = 1 [(gogoproto.customname) = "ID"];\n}\n\nmessage CommitSetInfo {\n  CommitSet commit_set = 1;\n  repeated CommitInfo commits = 2;\n}\n\nenum FileType {\n  RESERVED = 0;\n  FILE = 1;\n  DIR = 2;\n}\n\nmessage FileInfo {\n  File file = 1;\n  FileType file_type = 2;\n  google.protobuf.Timestamp committed = 3;\n  int64 size_bytes = 4;\n  bytes hash = 5;\n}\n\nmessage Project {\n  string name = 1;\n}\n\nmessage ProjectInfo {\n  Project project = 1;\n  string description = 2;\n  AuthInfo auth_info = 3;\n  google.protobuf.Timestamp created_at = 4;\n}\n\n// PFS API', metadata={'source': 'protobufs/pfs.proto'}), Document(page_content='message CreateRepoRequest {\n  Repo repo = 1;\n  string description = 2;\n  bool update = 3;\n}\n\nmessage InspectRepoRequest {\n  Repo repo = 1;\n}\n\nmessage ListRepoRequest {\n  // type is the type of (system) repos that should be returned\n  // an empty string requests all repos\n  string type = 1;\n  // projects filters out repos that do not belong in the list, while no projects means list all repos.\n  repeated Project projects = 2;\n}\n\nmessage DeleteRepoRequest {\n  Repo repo = 1;\n  bool force = 2;\n}\n\n// DeleteReposRequest is used to delete more than one repo at once.', metadata={'source': 'protobufs/pfs.proto'}), Document(page_content='message DeleteReposRequest {\n  // All repos in each project will be deleted if the caller has\n  // permission.\n  repeated Project projects = 1;\n  bool force = 2;\n  // If all is set, then all repos in all projects will be deleted if the caller\n  // has permission.\n  bool all = 3;\n}', metadata={'source': 'protobufs/pfs.proto'}), Document(page_content='message DeleteReposResponse {\n  repeated Repo repos = 1;\n}\n\n// CommitState describes the states a commit can be in.\n// The states are increasingly specific, i.e. a commit that is FINISHED also counts as STARTED.\nenum CommitState {\n  COMMIT_STATE_UNKNOWN = 0;\n  STARTED = 1; // The commit has been started, all commits satisfy this state.\n  READY = 2; // The commit has been started, and all of its provenant commits have been finished.\n  FINISHING = 3; // The commit is in the process of being finished.\n  FINISHED = 4; // The commit has been finished.\n}', metadata={'source': 'protobufs/pfs.proto'}), Document(page_content='message StartCommitRequest {\n  // parent may be empty in which case the commit that Branch points to will be used as the parent.\n  // If the branch does not exist, the commit will have no parent.\n  Commit parent = 1;\n  // description is a user-provided string describing this commit\n  string description = 2;\n  Branch branch = 3;\n}\n\nmessage FinishCommitRequest {\n  Commit commit = 1;\n  // description is a user-provided string describing this commit. Setting this\n  // will overwrite the description set in StartCommit\n  string description = 2;\n  string error = 3;\n  bool force = 4;\n}', metadata={'source': 'protobufs/pfs.proto'}), Document(page_content='message InspectCommitRequest {\n  Commit commit = 1;\n  // Wait causes inspect commit to wait until the commit is in the desired state.\n  CommitState wait = 2;\n}\n\nmessage ListCommitRequest {\n  Repo repo = 1;\n  Commit from = 2;\n  Commit to = 3;\n  int64 number = 4;\n  bool reverse = 5;  // Return commits oldest to newest\n  bool all = 6; // Return commits of all kinds (without this, aliases are excluded)\n  OriginKind origin_kind = 7; // Return only commits of this kind (mutually exclusive with all)\n  google.protobuf.Timestamp started_time = 8; // Return commits started before this time\n}', metadata={'source': 'protobufs/pfs.proto'}), Document(page_content='message InspectCommitSetRequest {\n  CommitSet commit_set = 1;\n  bool wait = 2; // When true, wait until all commits in the set are finished\n}\n\nmessage ListCommitSetRequest {\n  Project project = 1;\n}\n\nmessage SquashCommitSetRequest {\n  CommitSet commit_set = 1;\n}\n\nmessage DropCommitSetRequest {\n  CommitSet commit_set = 1;\n}', metadata={'source': 'protobufs/pfs.proto'}), Document(page_content="message SubscribeCommitRequest {\n  Repo repo = 1;\n  string branch = 2;\n  // only commits created since this commit are returned\n  Commit from = 3;\n  // Don't return commits until they're in (at least) the desired state.\n  CommitState state = 4;\n  bool all = 5; // Return commits of all kinds (without this, aliases are excluded)\n  OriginKind origin_kind = 6; // Return only commits of this kind (mutually exclusive with all)\n}\n\nmessage ClearCommitRequest {\n  Commit commit = 1;\n}", metadata={'source': 'protobufs/pfs.proto'}), Document(page_content="message ClearCommitRequest {\n  Commit commit = 1;\n}\n\nmessage CreateBranchRequest {\n  Commit head = 1;\n  Branch branch = 2;\n  repeated Branch provenance = 3;\n  Trigger trigger = 4;\n  bool new_commit_set = 5; // overrides the default behavior of using the same CommitSet as 'head'\n}\n\nmessage FindCommitsRequest {\n  Commit start = 1;\n  string file_path = 2;\n  uint32 limit = 3; // a limit of 0 means there is no upper bound on the limit.\n}\n\nmessage FindCommitsResponse {\n  oneof result {\n    Commit found_commit = 1;\n    Commit last_searched_commit = 2;\n  }\n  uint32 commits_searched = 3;\n}", metadata={'source': 'protobufs/pfs.proto'}), Document(page_content='message InspectBranchRequest {\n  Branch branch = 1;\n}\n\nmessage ListBranchRequest {\n  Repo repo = 1;\n  bool reverse = 2; // Returns branches oldest to newest\n}\n\nmessage DeleteBranchRequest {\n  Branch branch = 1;\n  bool force = 2;\n}\n\nmessage CreateProjectRequest {\n  Project project = 1;\n  string description = 2;\n  bool update = 3;\n}\n\nmessage InspectProjectRequest {\n  Project project = 1;\n}\n\nmessage ListProjectRequest {}\n\nmessage DeleteProjectRequest {\n  Project project = 1;\n  bool force = 2;\n}\n\nenum Delimiter {\n  NONE = 0;\n  JSON = 1;\n  LINE = 2;\n  SQL = 3;\n  CSV = 4;\n}', metadata={'source': 'protobufs/pfs.proto'}), Document(page_content='message AddFile {\n  string path = 1;\n  string datum = 2;\n\n  message URLSource {\n    string URL = 1;\n    bool recursive = 2;\n    uint32 concurrency = 3;\n  }\n  oneof source {\n    google.protobuf.BytesValue raw = 3;\n    URLSource url = 4;\n  }\n}\n\nmessage DeleteFile {\n  string path = 1;\n  string datum = 2;\n}\n\nmessage CopyFile {\n  string dst = 1;\n  string datum = 2;\n  File src = 3;\n  bool append = 4;\n}\n\nmessage ModifyFileRequest {\n  oneof body {\n    Commit set_commit = 1;\n    AddFile add_file = 2;\n    DeleteFile delete_file = 3;\n    CopyFile copy_file = 4;\n  }\n}', metadata={'source': 'protobufs/pfs.proto'}), Document(page_content='message GetFileRequest {\n  File file = 1;\n  string URL = 2;\n  int64 offset = 3;\n  PathRange path_range = 4;\n// TODO:\n//  int64 size_bytes = 3;\n}\n\nmessage InspectFileRequest {\n  File file = 1;\n}', metadata={'source': 'protobufs/pfs.proto'}), Document(page_content='message ListFileRequest {\n  reserved 2;', metadata={'source': 'protobufs/pfs.proto'}), Document(page_content='// File is the parent directory of the files we want to list. This sets the\n  // repo, the commit/branch, and path prefix of files we\'re interested in\n  // If the "path" field is omitted, a list of files at the top level of the repo\n  // is returned\n  File file = 1;\n  // Marker for pagination. If set, the files that come after the marker in\n  // lexicographical order will be returned. If reverse is also set, the files\n  // that come before the marker in lexicographical order will be returned.\n  File paginationMarker = 3;\n  // Number of files to return\n  int64 number = 4;', metadata={'source': 'protobufs/pfs.proto'}), Document(page_content='// Number of files to return\n  int64 number = 4;\n  // If true, return files in reverse order\n  bool reverse = 5;', metadata={'source': 'protobufs/pfs.proto'}), Document(page_content="// TODO:\n//  // History indicates how many historical versions you want returned. Its\n//  // semantics are:\n//  // 0: Return the files as they are at the commit in `file`. FileInfo.File\n//  //    will equal File in this request.\n//  // 1: Return the files as they are in the last commit they were modified in.\n//  //    (This will have the same hash as if you'd passed 0, but\n//  //    FileInfo.File.Commit will be different.\n//  // 2: Return the above and the files as they are in the next-last commit they\n//  //    were modified in.\n//  // 3: etc.\n//  //-1: Return all historical versions.", metadata={'source': 'protobufs/pfs.proto'}), Document(page_content='//  // 3: etc.\n//  //-1: Return all historical versions.\n//  int64 history = 3;\n}', metadata={'source': 'protobufs/pfs.proto'}), Document(page_content='message WalkFileRequest {\n    File file = 1;\n    // Marker for pagination. If set, the files that come after the marker in\n    // lexicographical order will be returned. If reverse is also set, the files\n    // that come before the marker in lexicographical order will be returned.\n    File paginationMarker = 2;\n    // Number of files to return\n    int64 number = 3;\n    // If true, return files in reverse order\n    bool reverse = 4;\n}\n\nmessage GlobFileRequest {\n  Commit commit = 1;\n  string pattern = 2;\n  PathRange path_range = 3;\n}', metadata={'source': 'protobufs/pfs.proto'}), Document(page_content="message DiffFileRequest {\n  File new_file = 1;\n  // OldFile may be left nil in which case the same path in the parent of\n  // NewFile's commit will be used.\n  File old_file = 2;\n  bool shallow = 3;\n}\n\nmessage DiffFileResponse {\n  FileInfo new_file = 1;\n  FileInfo old_file = 2;\n}\n\nmessage FsckRequest {\n  bool fix = 1;\n  oneof zombie_check {\n    Commit zombie_target = 2;\n    // run zombie data detection against all pipelines\n    bool zombie_all = 3;\n  }\n}\n\nmessage FsckResponse {\n  string fix = 1;\n  string error = 2;\n}\n\nmessage CreateFileSetResponse {\n  string file_set_id = 1;\n}", metadata={'source': 'protobufs/pfs.proto'}), Document(page_content='message GetFileSetRequest {\n  Commit commit = 1;\n}\n\nmessage AddFileSetRequest {\n  Commit commit = 1;\n  string file_set_id = 2;\n}\n\nmessage RenewFileSetRequest {\n  string file_set_id = 1;\n  int64 ttl_seconds = 2;\n}\n\nmessage ComposeFileSetRequest {\n  repeated string file_set_ids = 1;\n  int64 ttl_seconds = 2;\n  bool compact = 3;\n}\n\nmessage ShardFileSetRequest {\n  string file_set_id = 1;\n}\n\nmessage PathRange {\n  string lower = 1;\n  string upper = 2;\n}\n\nmessage ShardFileSetResponse {\n  repeated PathRange shards = 1;\n}', metadata={'source': 'protobufs/pfs.proto'}), Document(page_content='message CheckStorageRequest {\n  bool read_chunk_data = 1;\n  bytes chunk_begin = 2;\n  bytes chunk_end = 3;\n}\n\nmessage CheckStorageResponse {\n  int64 chunk_object_count = 1;\n}\n\nmessage PutCacheRequest {\n  string key = 1;\n  google.protobuf.Any value = 2;\n  repeated string file_set_ids = 3;\n  string tag = 4;\n}\n\nmessage GetCacheRequest {\n  string key = 1;\n}\n\nmessage GetCacheResponse {\n  google.protobuf.Any value = 1;\n}\n\nmessage ClearCacheRequest {\n  string tag_prefix = 1;\n}\n\nmessage ActivateAuthRequest {}\nmessage ActivateAuthResponse {}', metadata={'source': 'protobufs/pfs.proto'}), Document(page_content='message ActivateAuthResponse {}\n\nmessage RunLoadTestRequest {\n  string spec = 1;\n  Branch branch = 2;\n  int64 seed = 3;\n  string state_id = 4;\n}\n\nmessage RunLoadTestResponse {\n  string spec = 1;\n  Branch branch = 2;\n  int64 seed = 3;\n  string error = 4;\n  google.protobuf.Duration duration = 5;\n  string state_id = 6;\n}\n\nmessage ObjectStorageEgress {\n  string url = 1;\n}', metadata={'source': 'protobufs/pfs.proto'}), Document(page_content='message ObjectStorageEgress {\n  string url = 1;\n}\nmessage SQLDatabaseEgress {\n  message FileFormat {\n    enum Type {\n        UNKNOWN = 0;\n        CSV = 1;\n        JSON = 2;\n        PARQUET = 3;\n    }\n    Type type = 1;\n    repeated string columns = 2;\n  }\n  message Secret {\n    string name = 1;\n    string key = 2;\n  }\n\n  string url = 1;\n  FileFormat file_format = 2;\n  Secret secret = 3;\n}\nmessage EgressRequest {\n  pfs_v2.Commit commit = 1;\n  oneof target {\n    ObjectStorageEgress object_storage = 2;\n    SQLDatabaseEgress sql_database = 3;\n  }\n}', metadata={'source': 'protobufs/pfs.proto'}), Document(page_content='message EgressResponse {\n  message ObjectStorageResult {\n    int64 bytes_written = 1;\n  }\n  message SQLDatabaseResult {\n    map<string, int64> rows_written = 1;\n  }\n\n  oneof result {\n    ObjectStorageResult object_storage = 1;\n    SQLDatabaseResult sql_database = 2;\n  }\n}', metadata={'source': 'protobufs/pfs.proto'}), Document(page_content='service API {\n  // CreateRepo creates a new repo.\n  rpc CreateRepo(CreateRepoRequest) returns (google.protobuf.Empty) {}\n  // InspectRepo returns info about a repo.\n  rpc InspectRepo(InspectRepoRequest) returns (RepoInfo) {}\n  // ListRepo returns info about all repos.\n  rpc ListRepo(ListRepoRequest) returns (stream RepoInfo) {}\n  // DeleteRepo deletes a repo.\n  rpc DeleteRepo(DeleteRepoRequest) returns (google.protobuf.Empty) {}\n  // DeleteRepos deletes more than one repo at once.  It attempts to\n  // delete every repo matching the DeleteReposRequest.  When deleting', metadata={'source': 'protobufs/pfs.proto'}), Document(page_content='// all repos matching a project, any repos not deletable by the\n  // caller will remain, and the project will not be empty; this is\n  // not an error.  The returned DeleteReposResponse will contain a\n  // list of all actually-deleted repos.\n  rpc DeleteRepos(DeleteReposRequest) returns (DeleteReposResponse) {}', metadata={'source': 'protobufs/pfs.proto'}), Document(page_content='// StartCommit creates a new write commit from a parent commit.\n  rpc StartCommit(StartCommitRequest) returns (Commit) {}\n  // FinishCommit turns a write commit into a read commit.\n  rpc FinishCommit(FinishCommitRequest) returns (google.protobuf.Empty) {}\n  // ClearCommit removes all data from the commit.\n  rpc ClearCommit(ClearCommitRequest) returns (google.protobuf.Empty) {}\n  // InspectCommit returns the info about a commit.\n  rpc InspectCommit(InspectCommitRequest) returns (CommitInfo) {}\n  // ListCommit returns info about all commits.', metadata={'source': 'protobufs/pfs.proto'}), Document(page_content='// ListCommit returns info about all commits.\n  rpc ListCommit(ListCommitRequest) returns (stream CommitInfo) {}\n  // SubscribeCommit subscribes for new commits on a given branch.\n  rpc SubscribeCommit(SubscribeCommitRequest) returns (stream CommitInfo) {}', metadata={'source': 'protobufs/pfs.proto'}), Document(page_content='// InspectCommitSet returns the info about a CommitSet.\n  rpc InspectCommitSet(InspectCommitSetRequest) returns (stream CommitInfo) {}\n  // ListCommitSet returns info about all CommitSets.\n  rpc ListCommitSet(ListCommitSetRequest) returns (stream CommitSetInfo) {}\n  // SquashCommitSet squashes the commits of a CommitSet into their children.\n  rpc SquashCommitSet(SquashCommitSetRequest) returns (google.protobuf.Empty) {}\n  // DropCommitSet drops the commits of a CommitSet and all data included in the commits.\n  rpc DropCommitSet(DropCommitSetRequest) returns (google.protobuf.Empty) {}', metadata={'source': 'protobufs/pfs.proto'}), Document(page_content='// FindCommits searches for commits that reference a supplied file being modified in a branch.\n  rpc FindCommits(FindCommitsRequest) returns (stream FindCommitsResponse) {}', metadata={'source': 'protobufs/pfs.proto'}), Document(page_content='// CreateBranch creates a new branch.\n  rpc CreateBranch(CreateBranchRequest) returns (google.protobuf.Empty) {}\n  // InspectBranch returns info about a branch.\n  rpc InspectBranch(InspectBranchRequest) returns (BranchInfo) {}\n  // ListBranch returns info about the heads of branches.\n  rpc ListBranch(ListBranchRequest) returns (stream BranchInfo) {}\n  // DeleteBranch deletes a branch; note that the commits still exist.\n  rpc DeleteBranch(DeleteBranchRequest) returns (google.protobuf.Empty) {}', metadata={'source': 'protobufs/pfs.proto'}), Document(page_content='// ModifyFile performs modifications on a set of files.\n  rpc ModifyFile(stream ModifyFileRequest) returns (google.protobuf.Empty) {}\n  // GetFile returns the contents of a single file\n  rpc GetFile(GetFileRequest) returns (stream google.protobuf.BytesValue) {}\n  // GetFileTAR returns a TAR stream of the contents matched by the request\n  rpc GetFileTAR(GetFileRequest) returns (stream google.protobuf.BytesValue) {}\n  // InspectFile returns info about a file.\n  rpc InspectFile(InspectFileRequest) returns (FileInfo) {}\n  // ListFile returns info about all files.', metadata={'source': 'protobufs/pfs.proto'}), Document(page_content='// ListFile returns info about all files.\n  rpc ListFile(ListFileRequest) returns (stream FileInfo) {}\n  // WalkFile walks over all the files under a directory, including children of children.\n  rpc WalkFile(WalkFileRequest) returns (stream FileInfo) {}\n  // GlobFile returns info about all files.\n  rpc GlobFile(GlobFileRequest) returns (stream FileInfo) {}\n  // DiffFile returns the differences between 2 paths at 2 commits.\n  rpc DiffFile(DiffFileRequest) returns (stream DiffFileResponse) {}', metadata={'source': 'protobufs/pfs.proto'}), Document(page_content='// ActivateAuth creates a role binding for all existing repos\n  rpc ActivateAuth(ActivateAuthRequest) returns (ActivateAuthResponse) {}\n\n  // DeleteAll deletes everything.\n  rpc DeleteAll(google.protobuf.Empty) returns (google.protobuf.Empty) {}\n  // Fsck does a file system consistency check for pfs.\n  rpc Fsck(FsckRequest) returns (stream FsckResponse) {}', metadata={'source': 'protobufs/pfs.proto'}), Document(page_content='// FileSet API\n  // CreateFileSet creates a new file set.\n  rpc CreateFileSet(stream ModifyFileRequest) returns (CreateFileSetResponse) {}\n  // GetFileSet returns a file set with the data from a commit\n  rpc GetFileSet(GetFileSetRequest) returns (CreateFileSetResponse) {}\n  // AddFileSet associates a file set with a commit\n  rpc AddFileSet(AddFileSetRequest) returns (google.protobuf.Empty) {}\n  // RenewFileSet prevents a file set from being deleted for a set amount of time.\n  rpc RenewFileSet(RenewFileSetRequest) returns (google.protobuf.Empty) {}', metadata={'source': 'protobufs/pfs.proto'}), Document(page_content='// ComposeFileSet composes a file set from a list of file sets.\n  rpc ComposeFileSet(ComposeFileSetRequest) returns (CreateFileSetResponse) {}\n  rpc ShardFileSet(ShardFileSetRequest) returns (ShardFileSetResponse) {}\n  // CheckStorage runs integrity checks for the storage layer.\n  rpc CheckStorage(CheckStorageRequest) returns (CheckStorageResponse) {}\n  rpc PutCache(PutCacheRequest) returns (google.protobuf.Empty) {}\n  rpc GetCache(GetCacheRequest) returns (GetCacheResponse) {}\n  rpc ClearCache(ClearCacheRequest) returns (google.protobuf.Empty) {}', metadata={'source': 'protobufs/pfs.proto'}), Document(page_content='// RunLoadTest runs a load test.\n  rpc RunLoadTest(RunLoadTestRequest) returns (RunLoadTestResponse) {}\n  // RunLoadTestDefault runs the default load tests.\n  rpc RunLoadTestDefault(google.protobuf.Empty) returns (RunLoadTestResponse) {}\n\n  // ListTask lists PFS tasks\n  rpc ListTask(taskapi.ListTaskRequest) returns (stream taskapi.TaskInfo) {}\n\n  // Egress writes data from a commit to an external system\n  rpc Egress(EgressRequest) returns (EgressResponse) {}', metadata={'source': 'protobufs/pfs.proto'}), Document(page_content='// Project API\n  // CreateProject creates a new project.\n  rpc CreateProject(CreateProjectRequest) returns (google.protobuf.Empty) {}\n  // InspectProject returns info about a project.\n  rpc InspectProject(InspectProjectRequest) returns (ProjectInfo) {}\n  // ListProject returns info about all projects.\n  rpc ListProject(ListProjectRequest) returns (stream ProjectInfo) {}\n  // DeleteProject deletes a project.\n  rpc DeleteProject(DeleteProjectRequest) returns (google.protobuf.Empty) {}\n}', metadata={'source': 'protobufs/pfs.proto'})]


[Document(page_content='syntax = "proto3";\n\npackage admin_v2;\noption go_package = "github.com/pachyderm/pachyderm/v2/src/admin";\n\nimport "gogoproto/gogo.proto";\nimport "version/versionpb/version.proto";\n\nmessage ClusterInfo {\n  string id = 1 [(gogoproto.customname) = "ID"];\n  string deployment_id = 2 [(gogoproto.customname) = "DeploymentID"];\n\n  bool version_warnings_ok = 3; // Let the client detect a server that can\'t generate warnings.\n  repeated string version_warnings = 4; // Warnings about version skew.\n\n  string proxy_host = 5;\n  bool proxy_tls = 6;\n}', metadata={'source': 'protobufs/admin.proto'}), Document(page_content='message InspectClusterRequest {\n  versionpb_v2.Version client_version = 1;\n}\n\nservice API {\n  rpc InspectCluster(InspectClusterRequest) returns (ClusterInfo) {}\n}', metadata={'source': 'protobufs/admin.proto'})]


[Document(page_content='syntax = "proto3";\n\npackage common;\noption go_package = "github.com/pachyderm/pachyderm/v2/src/server/worker/common";\n\nimport "pfs/pfs.proto";\nimport "gogoproto/gogo.proto";\n\nmessage Input {\n  reserved 2;\n\n  pfs_v2.FileInfo file_info = 1;\n  string name = 3;\n  string join_on = 4;\n  bool outer_join = 5;\n  string group_by = 6;\n  bool lazy = 7;\n  string branch = 8;\n  string git_url = 9 [(gogoproto.customname) = "GitURL"];\n  bool empty_files = 10;\n  bool s3 = 11; // If set, workers won\'t create an input directory for this input\n}', metadata={'source': 'protobufs/common.proto'})]


